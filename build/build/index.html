<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Prez</title>

    <meta name="description" content="-- DESCRIPTION HERE --">
    <meta name="author" content="ijcd">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/solarized.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="css/highlight/styles/zenburn.css" id="highlight-theme">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <link rel="stylesheet" href="css/custom.css">

  </head>

  <body>

    <div class="reveal">
      <div class="slides"><section id="stately-state-machines-with-ragel" class="slide" data-has-notes="true">
<h2>Stately State Machines With Ragel</h2><p><img src="images/babbage.jpg" alt=""></p>
<p>RubyConf 2015
Ian Duggan</p><aside class="notes"><p>Joke: Statistician and Mathematician — please analyze this number — it’s two. Statistician: somewhere between 1.99999999 and 2.00000001 but we can’t be sure. Engineer: 2? It’s 2? Ok, well, we should make it 3. No, you know what? Let’s make it 4 just to be safe.</p></aside>
</section>
<section id="hello" class="slide">
<h2>Hello</h2><p>Hi, my name is Ian Duggan</p>
<p><img src="images/ian_carrot.jpg" alt=""></p>
</section>
<section id="i-play-hockey" class="slide">
<h2>I Play Hockey</h2><p>Several times a week.</p>
<p><img src="images/stormy_the_pig.jpg" alt=""></p>
</section>
<section id="i-play-guitar" class="slide">
<h2>I Play Guitar</h2><p>And banjo. And mandolin. And ukulele. Poorly. I have a fiddle that&#39;s gathering dust.</p>
<p><img src="images/musical_instruments.jpg" alt=""></p>
</section>
<section id="sometimes-i-fly" class="slide">
<h2>Sometimes I Fly</h2><p><img src="images/cessna120.jpg" alt=""></p>
</section>
<section id="i-love-my-cats" class="slide">
<h2>I Love My Cats</h2><p><img src="images/boofus_cozy1.jpg" alt=""></p>
</section>
<section id="they-are-goofballs" class="slide">
<h2>They Are Goofballs</h2><p><img src="images/minnie_antlers.jpg" alt=""></p>
</section>
<section id="but-very-furry" class="slide">
<h2>But Very Furry</h2><p><img src="images/boofus_cozy2.jpg" alt=""></p>
</section>
<section id="and-dopey" class="slide">
<h2>And Dopey</h2><p><img src="images/minnie_hoodie.jpg" alt=""></p>
</section>
<section id="and-relaxed" class="slide">
<h2>And Relaxed</h2><p><img src="images/boofus_relaxed.jpg" alt=""></p>
</section>
<section id="and-fun" class="slide">
<h2>And Fun</h2><p><img src="images/minnie_bucket.jpg" alt=""></p>
</section>
<section id="software-ftw" class="slide">
<h2>Software! FTW!</h2><p>I&#39;m a software dude. I code things. I code the internets and the
googles. I&#39;m also a recovering technology entrepreneur. I&#39;ve been in
and out of startup institutions my entire life.</p>
<p><img src="images/software_eng.jpg" alt=""></p>
</section>
<section id="current-status" class="slide">
<h2>Current Status</h2><p><img src="images/twitch.jpg" alt=""></p>
</section>
<section id="were-hiring-of-course" class="slide">
<h2>We&#39;re Hiring (of course)</h2><p>Lots of Ruby.</p>
<p><img src="images/ruby.png" alt=""></p>
</section>
<section id="were-hiring-of-course" class="slide">
<h2>We&#39;re Hiring (of course)</h2><p>Lots of Go.</p>
<p><img src="images/gopher.jpg" alt=""></p>
</section>
<section id="im-a-rubyist-since-" class="slide" data-has-notes="true">
<h2>I&#39;m a Rubyist, since 1.6</h2><p>I&#39;ve been using Ruby casually since the 1.6 days, and professionally
for more than a decade.</p>
<p><img src="images/ruby_16.jpg" alt=""></p><aside class="notes"><p>I forget when the transition exactly happened,
but one day I just found myself using Ruby for everything. It&#39;s a very
nice language.</p></aside>
</section>
<section id="today-is-about-ragel" class="slide" data-has-notes="true">
<h2>Today is About Ragel</h2><p><img src="images/ragel.png" alt=""></p><aside class="notes"><p>However, today I&#39;m here to talk to you today about another incredible
tool, Ragel.</p>
<p>It&#39;s amazing. It can do almost anything.</p>
<p>Well, almost anything.</p>
<p>Actually, nearly anything related to parsing text.</p>
<p>You can get a few more tricks out of it but that&#39;s the main use case.</p></aside>
</section>
<section id="ragel-is-really-cool" class="slide">
<h2>Ragel Is Really Cool</h2><p>If you don&#39;t have it in your bat-belt yet, you need to add it. Today!</p>
<p><img src="images/adam_west_batman.jpg" alt=""></p>
</section>
<section id="but-regular-expressions-are-easy" class="slide" data-has-notes="true">
<h2>But Regular Expressions are easy!</h2><p>zarro boogs found</p>
<p><img src="images/regular_expression.jpg" alt=""></p><aside class="notes"><p>What&#39;s that you say? Parsing text?</p>
<p>Parsing text is easy.</p>
<p>You just use regular expressions, right?</p>
<p>Simple. No problem.</p>
<p>They have their place, but you can reach for something better.</p></aside>
</section>
<section id="formally" class="slide">
<h2>Formally</h2><pre><code><span class="hljs-label">https:</span>//en.wikipedia<span class="hljs-preprocessor">.org</span>/wiki/Regular_expression
</code></pre><p>   &quot;Regular expressions consist of constants and operator symbols that denote sets of strings and operations over these sets, respectively.&quot;
   (empty set) ∅ denoting the set ∅.
   (empty string) ε denoting the set containing only the &quot;empty&quot; string, which has no characters at all.
   (literal character) a in Σ denoting the set containing only the character a.
   (concatenation) RS denotes the set of strings that can be obtained by concatenating a string in R and a string in S.
   (alternation) R | S denotes the set union of sets described by R and S.
   (Kleene star) R* denotes the smallest superset of set described by R that contains ε and is closed under string concatenation.</p>
</section>
<section id="less-formally" class="slide">
<h2>Less Formally</h2><p>   Match
   &quot;a&quot; - match &quot;a&quot;</p>
<p>   Boolean AND
   &quot;abc&quot; - match &quot;a&quot;, then &quot;b&quot;, then &quot;c&quot;</p>
<p>   Boolean OR
   &quot;a&quot; | &quot;b&quot; - match &quot;a&quot; or &quot;b&quot; (boolean OR)</p>
<p>   Grouping for Precedence
   gr(a|e)y - match &quot;gr&quot;, then &quot;a&quot; or &quot;e&quot;, then &quot;y&quot;</p>
<p>   Quantification
   a? - match zero or one &quot;a&quot;
   a* - match zero or more &quot;a&quot;
   a+ - match one or more &quot;a&quot;
   a{18} - match &quot;a&quot; 18 times
   a{2,} - match &quot;a&quot; 2 or more times
   a{2,10} - match &quot;a&quot; between 2 and 10 more times</p>
</section>
<section id="regexps-are-ok" class="slide">
<h2>Regexps Are Ok</h2><p>You can get by with them. You can especially get by with them in Ruby which draws it&#39;s heritage from Perl, Sed, and Awk which made wonderful use of regexps.</p>
</section>
<section id="ruby-has-great-tools-for-regular-expressions" class="slide">
<h2>Ruby has great tools for regular expressions.</h2><p>  (show simple matching)
  (ruby gsub block trick)</p>
</section>
<section id="sometimes-you-want-more-control" class="slide">
<h2>Sometimes You Want More Control</h2><p>Those work fine. Why do we need something better?</p>
<pre><code><span class="hljs-comment">%%{</span>
  <span class="hljs-function_or_atom">machine</span> <span class="hljs-function_or_atom">url_scanner</span>;
  <span class="hljs-function_or_atom">scheme</span> = <span class="hljs-string">'ftp'</span> | /<span class="hljs-function_or_atom">https</span>?/;


}<span class="hljs-comment">%%</span>
</code></pre><p>  (find a REALLY ugly picture of a regular expression)</p>
</section>
<section id="deterministic-finite-automaton-dfa" class="slide">
<h2>Deterministic Finite Automaton (DFA)</h2><p>Can be in only one state at a time.</p>
</section>
<section id="nondeterministic-finite-automaton-nfa" class="slide">
<h2>Nondeterministic Finite Automaton (NFA)</h2><p>Can be in more than one state at a time.</p>
</section>
<section id="nondeterministic-finite-automaton-nfa" class="slide">
<h2>Nondeterministic Finite Automaton (NFA)</h2><p>But, we can convert this into a DFA but making &quot;super states&quot; from these dual states. This grows combinatorically, of course.</p>
</section>
<section id="equivalence-of-regular-expressions-nfas-and-dfas" class="slide">
<h2>Equivalence of Regular Expressions, NFAs, and DFAs</h2><p>  &quot;It is possible to convert freely between regular expressions,
  deterministic finite automata, and nondeterministic finite
  automata. Given one, we can convert it to any of the other forms&quot;</p>
<p>  <a href="http://faculty.ycp.edu/~dhovemey/fall2008/cs340/notes/lecture3.html">http://faculty.ycp.edu/~dhovemey/fall2008/cs340/notes/lecture3.html</a></p>
</section>
<section id="whats-a-state-machine-you-ask" class="slide">
<h2>What&#39;s a state machine you ask?</h2><p>State machines are an important tool in computer programming, and Ragel is a wonderful tool for creating them.</p>
</section>
<section id="state-machines-are-everywhere" class="slide">
<h2>State machines are everywhere.</h2>
</section>
<section id="theyre-in-your-stoplight" class="slide">
<h2>They&#39;re in your stoplight.</h2><p>  (show stoplight state machine)</p>
</section>
<section id="they-run-your-cpu" class="slide" data-has-notes="true">
<h2>They run your CPU.</h2><p>  (find a picture of a register machine?)</p><aside class="notes"><p>Every tick of your CPU advancing a state machine from one state to
another. Take all of the bits in your computer and label each
combination as a state. Take all of the input bits and label those as
different inputs. That&#39;s a big horkin&#39; state machine.</p></aside>
</section>
<section id="there-are-examples-everywhere" class="slide">
<h2>There are examples everywhere:</h2><p>  number classification
  watch with timer
  vending machine
  traffic light
  bar code scanner
  gas pumps</p>
</section>
<section id="slide-title" class="slide">
<p>State machines are great for many reasons. They are simple to understand, and there has been a great deal of research around finite automata and state machines. With the right approach they can also produce code that is faster, easier to maintain, and more correct and thus more secure.</p>
</section>
<section id="slide-title" class="slide">
<p>Rather than me trying to convince you that they&#39;re useful, let&#39;s just talk about them for a bit and see where we end up.</p>
</section>
<section id="slide-title" class="slide">
<p>Let&#39;s go over some vocabulary.</p>
</section>
<section id="slide-title" class="slide">
<p>Start state.
  This is the initial state of a mchine.
  (S0)</p>
</section>
<section id="slide-title" class="slide">
<p>Accept state.
  In this state, the machine is said to have &quot;accepted&quot; the input.
  (double circle)</p>
</section>
<section id="slide-title" class="slide">
<p>Transition.
  Upon consuming a single character, the machine can move from one state to another.
  (labelled arrow)</p>
</section>
<section id="slide-title" class="slide">
<p>Epsilon Transition
  Allows an automaton to change its state spontaneously, i.e. without consuming an input symbol
  These can be used to wire machines together. Composition. Computer science.
  (show an epsilon)</p>
</section>
<section id="slide-title" class="slide">
<p>One state machines.
  (a)
  (a*)
  (a+)</p>
</section>
<section id="slide-title" class="slide">
<p>Two state machines.</p>
<p>  Two states, we start to get useful. (make an oscillator - light on
  and off, w/ a counter for timing — this is how we have memory in the
  network — sort of like markov chains w/ memory)</p>
<p>  (oscillator)</p>
</section>
<section id="slide-title" class="slide">
<p>And we can add more states to get somewhere useful.
  Zero or more hellos
  (hello)*</p>
</section>
<section id="slide-title" class="slide">
<p>But we&#39;re here to talk about Ragel, specifically, so it must have something to do with all of this.</p>
</section>
<section id="slide-title" class="slide">
<p>What is Ragel?</p>
<p>  <a href="https://en.wikipedia.org/wiki/Ragel">https://en.wikipedia.org/wiki/Ragel</a></p>
<p>  &quot;Ragel is a finite-state machine compiler with output support for C,
  C++, C#, Objective-C, D, Java, OCaml, Go, and Ruby source code.
  It supports the generation of table or control flow driven state
  machines from regular expressions and/or state charts and can
  also build lexical analysers via the longest-match method. Ragel
  specifically targets text parsing and input validation.&quot;</p>
<p>  &quot;Ragel supports the generation of table or control flow driven state
  machines from regular expressions and/or state charts and can also
  build lexical analysers via the longest-match method. A unique feature
  of Ragel is that user actions can be associated with arbitrary state
  machine transitions using operators that are integrated into the
  regular expressions. Ragel also supports visualization of the
  generated machine via graphviz.&quot;</p>
</section>
<section id="slide-title" class="slide">
<p>Let&#39;s talk about pronounciation (pro-nouns-key-ay-shun) for a sec.</p>
</section>
<section id="slide-title" class="slide">
<p>Is it RAY-gull or RAU-jul or RAH-gull, or RAH-jul?</p>
</section>
<section id="slide-title" class="slide">
<p>Let&#39;s get it from the horse&#39;s mouth.</p>
<p>  (picture of a horse&#39;s mouth)</p>
</section>
<section id="slide-title" class="slide">
<p>Re: [ragel-users] pronounciation</p>
<pre><code>Re: [ragel-users] pronounciation
Adrian Thurston Sat, <span class="hljs-number">10</span> Apr <span class="hljs-number">2010</span> <span class="hljs-number">09</span>:<span class="hljs-number">02</span>:<span class="hljs-number">10</span> -<span class="hljs-number">0700</span>

Hi Landon,

I usually say something like <span class="hljs-string">"rah-ghel."</span> I had no
phonetic basis <span class="hljs-keyword">for</span> it <span class="hljs-keyword">when</span> I picked it. I just took my nickname
<span class="hljs-string">"Age"</span> <span class="hljs-keyword">and</span> wrapped it <span class="hljs-keyword">in</span> the R <span class="hljs-keyword">and</span> L <span class="hljs-keyword">of</span> regular languages. I<span class="hljs-attribute">'ve</span>
since learned that it means <span class="hljs-string">"man"</span> <span class="hljs-keyword">in</span> Arabic.

Adrian

Landon Cox wrote:
&gt; Hi Adrian <span class="hljs-keyword">and</span> <span class="hljs-keyword">others</span>,
&gt;
&gt; Simple question:  What <span class="hljs-keyword">is</span> the pronunciation <span class="hljs-keyword">of</span> <span class="hljs-string">"Ragel"</span>?
&gt; 
&gt; <span class="hljs-keyword">Is</span> it <span class="hljs-string">"Ray-Gull"</span> <span class="hljs-keyword">or</span> <span class="hljs-string">"Rag-El"</span> (like dish rag) <span class="hljs-keyword">or</span> <span class="hljs-string">"Rage-El"</span> ?
&gt;
&gt; Thanks,
&gt; 
&gt; Landon

https://www.mail-archive.com/ragel-users@complang.org/msg00344.html
</code></pre>
</section>
<section id="slide-title" class="slide">
<p>Well, darn. I&#39;ve been pronouncing it wrong for quite some time!</p>
</section>
<section id="slide-title" class="slide">
<p>Ragel is a DSL for creating state machines.</p>
</section>
<section id="slide-title" class="slide">
<p>It is espcially useful for parsing protocols and data formats. (HTTP, XML, JSON, CSS, etc...)</p>
</section>
<section id="slide-title" class="slide">
<p>From a high-level, it helps you build regular expressions, but with an
important difference. With Ragel, you have the ability to stop at any
point in the regexp parse and execute code in the host language. This
is incredibly powerful. It means that rather than having a large
program with lots of regexps, loops, and conditionals, we can have one
BNF-ish looking definition that, instead, calls out to our code when
we need it to. You can do some really cool tricks with this.</p>
</section>
<section id="slide-title" class="slide">
<p>Let&#39;s look at the DSL.</p>
</section>
<section id="slide-title" class="slide">
<p>Actions.</p>
<blockquote>
<p>name - starting
%name - leaving
$name - all transitions
@name - finishing</p>
</blockquote>
</section>
<section id="slide-title" class="slide">
<p>You can do a lot in an action. Actions are written in the host language.</p>
<ul>
<li>explicitly change the current state</li>
<li>push current state to a stack and jump to another state</li>
<li>exit the parser</li>
<li>google a matched link, take the first page, download a video from it, upload it to youtube</li>
</ul>
</section>
<section id="slide-title" class="slide">
<p>String extraction</p>
<ul>
<li><blockquote>
<p>mark - mark the beginning a pattern</p>
</blockquote>
</li>
<li>%emit - save the currently matched pattern</li>
</ul>
</section>
<section id="slide-title" class="slide">
<p>It&#39;s possible to have a single Ragel definition that uses import semantics to allow implementing the actions in different languages using the same parent Ragel file
  (link to Mongrel)
  <a href="https://github.com/taf2/mongrel/tree/master/ext/http11">https://github.com/taf2/mongrel/tree/master/ext/http11</a></p>
</section>
<section id="slide-title" class="slide">
<p>It&#39;s also possible to prototype in Ruby, then convert it to a C module for super speed. Ragel supports several output formats so you can do this port rather easily.
  (see Zed Shaw&#39;s http11 for an example of how to do this)
  <a href="https://github.com/taf2/mongrel/tree/master/ext/http11">https://github.com/taf2/mongrel/tree/master/ext/http11</a></p>
</section>
<section id="slide-title" class="slide">
<p>General Structure of a Ragel File</p>
<ul>
<li>mostly in the host language</li>
<li>%% is used for inline statements</li>
<li>%%{ is used for multiline statements }%%</li>
</ul>
</section>
<section id="slide-title" class="slide">
<p>Several host languages are available.</p>
<pre><code>host language:
   -<span class="ruby"><span class="hljs-constant">C</span>                   <span class="hljs-constant">The</span> host language is <span class="hljs-constant">C</span>, <span class="hljs-constant">C</span>++, <span class="hljs-constant">Obj</span>-<span class="hljs-constant">C</span> <span class="hljs-keyword">or</span> <span class="hljs-constant">Obj</span>-<span class="hljs-constant">C</span>++ (default)
</span>   -<span class="ruby"><span class="hljs-constant">D</span>                   <span class="hljs-constant">The</span> host language is <span class="hljs-constant">D</span>
</span>   -<span class="ruby"><span class="hljs-constant">Z</span>                   <span class="hljs-constant">The</span> host language is <span class="hljs-constant">Go</span>
</span>   -<span class="ruby"><span class="hljs-constant">J</span>                   <span class="hljs-constant">The</span> host language is <span class="hljs-constant">Java</span>
</span>   -<span class="ruby"><span class="hljs-constant">R</span>                   <span class="hljs-constant">The</span> host language is <span class="hljs-constant">Ruby</span>
</span>   -<span class="ruby"><span class="hljs-constant">A</span>                   <span class="hljs-constant">The</span> host language is <span class="hljs-constant">C</span><span class="hljs-comment">#</span>
</span>   -<span class="ruby"><span class="hljs-constant">O</span>                   <span class="hljs-constant">The</span> host language is <span class="hljs-constant">OCaml</span></span>
</code></pre>
</section>
<section id="slide-title" class="slide">
<p>Minimal Ragel File</p>
<ul>
<li><p>Has a .rl extension (simple.rl)</p>
<p> %%{
   machine simple;
   main := &#39;simple&#39;;
 }%%</p>
</li>
</ul>
</section>
<section id="slide-title" class="slide">
<p>that defines the basic machine. Ragel will use this to compute the set of states and transitions. It will then use those to generate code in a number of different styes:</p>
<pre><code>code style:<span class="hljs-function"> (</span>C/D/Java/Ruby/C<span class="hljs-comment">#/OCaml)</span>
   -T0                  Table driven FSM<span class="hljs-function"> (</span>default<span class="hljs-function">)</span>

code style:<span class="hljs-function"> (</span>C/D/Ruby/C<span class="hljs-comment">#/OCaml)</span>
   -T1                  Faster table driven FSM
   -F0                  Flat table driven FSM
   -F1                  Faster flat table-driven FSM

code style:<span class="hljs-function"> (</span>C/D/C<span class="hljs-comment">#/OCaml)</span>
   -G0                  Goto-driven FSM
   -G1                  Faster<span class="hljs-instruction"> goto-driven </span>FSM

code style:<span class="hljs-function"> (</span>C/D<span class="hljs-function">)</span>
   -G2                  Really fast<span class="hljs-instruction"> goto-driven </span>FSM
   -P&lt;N&gt;                N-Way Split really fast<span class="hljs-instruction"> goto-driven </span>FSM
</code></pre>
</section>
<section id="slide-title" class="slide">
<p>Each of these has different visual organization and performance
characteristics. In languages like C, this can boil down to
heavily-optimized GOTO statements in a single while loop. It&#39;s fast
and cpu-cache friendly.</p>
<pre><code>(pull <span class="hljs-built_in">open</span> <span class="hljs-operator">a</span> ruby <span class="hljs-built_in">file</span> <span class="hljs-operator">and</span> <span class="hljs-built_in">get</span> <span class="hljs-operator">an</span> idea <span class="hljs-operator">of</span> what this looks like)
</code></pre>
</section>
<section id="slide-title" class="slide">
<p>There are three main directives that do the bulk of the work.</p>
<p>  %%write init;    (initializes the data buffer and sets the current state)</p>
<p>  %%write data;    (writes out definitions of the state and transition data)</p>
<p>  %%write exec;    (writes out the code that processes the data buffer using the state and transition data)</p>
</section>
<section id="slide-title" class="slide">
<p>%%write data;</p>
<p>  class &lt;&lt; self
      attr_accessor :_hello_key_offsets
      private :_hello_key_offsets, :_hello_key_offsets=
  end
  self._hello_key_offsets = [
      0, 0, 1, 2, 3, 4
  ]</p>
<p>  class &lt;&lt; self
      attr_accessor :_hello_trans_keys
      private :_hello_trans_keys, :_hello_trans_keys=
  end
  self._hello_trans_keys = [
      101, 108, 108, 111, 104, 0
  ]</p>
<h1>LOTS MORE LIKE THIS</h1><h1>...</h1><h1>...</h1>
</section>
<section id="slide-title" class="slide">
<p>%%write init;</p>
<p>  begin
    p ||= 0
    pe ||= data.length
    cs = simple_start
    top = 0
  end</p>
</section>
<section id="slide-title" class="slide">
<p>%%write exec;</p>
<p>   begin
       _klen, _trans, _keys = nil
       _goto_level = 0
       _resume = 10
       _eof_trans = 15
       _again = 20
       _test_eof = 30
       _out = 40
       while true
       _trigger_goto = false
       if _goto_level &lt;= 0</p>
<pre><code><span class="hljs-preprocessor"># LOTS MORE LIKE THIS</span>
<span class="hljs-preprocessor"># ...</span>
<span class="hljs-preprocessor"># ...    </span>
</code></pre><p>  end</p>
</section>
<section id="slide-title" class="slide">
<p>Basic Machines
We&#39;ll next go into some very basic state machines with diagrams and examples of the Ragel syntax used to create them.</p>
</section>
<section id="slide-title" class="slide">
<p>Naming a Machine</p>
<p>  machine phone_parser;</p>
<p>  A machine’s statements can be spread across multiple machine
  specifications. This allows one to break up a machine across several
  files or draw in statements that are common to multiple machines
  using the include statement.</p>
</section>
<section id="slide-title" class="slide">
<p>Machine Definition</p>
<p>  <name> = <expression>;</p>
</section>
<section id="slide-title" class="slide">
<p>Machine Instantiation</p>
<p>  <name> := <expression>;</p>
</section>
<section id="slide-title" class="slide">
<p>File Inclusion</p>
<p>  include FsmName &quot;inputfile.rl&quot;;</p>
</section>
<section id="slide-title" class="slide">
<p>Import Definitions</p>
<p>  import &quot;inputfile.h&quot;;</p>
<p>  The import statement scrapes a file for sequences of tokens that match the following forms.
  Ragel treats these forms as state machine definitions.
  • name ’=’ number
  • name ’=’ lit_string
  • ’define’ name number
  • ’define’ name lit_string</p>
</section>
<section id="slide-title" class="slide">
<p>Building Up Basic Matchers</p>
<h1>is used for single line comments</h1>
</section>
<section id="slide-title" class="slide">
<p>Literals</p>
<p>  &quot;&quot;, &#39;&#39;, //, []</p>
</section>
<section id="slide-title" class="slide">
<p>Escape Characters</p>
<p>  \0 \a \b \t \n \v \f \r</p>
<p>  You can escape the end of a line with a \ (as in shell scripting)</p>
</section>
<section id="slide-title" class="slide">
<p>Host Language Code</p>
<p>  {} delimit host language code</p>
</section>
<section id="slide-title" class="slide">
<p>Numbers</p>
<p>  [+-]?[0-9]+      integers used for specifying machine states
  0x[0-9A-fa-f]    hexadecimals</p>
</section>
<section id="slide-title" class="slide">
<p>Keywords</p>
<p>  access
  actionalphtype
  getkey
  write
  machine
  include</p>
</section>
<section id="slide-title" class="slide">
<p>Whitespace</p>
<p>  Any amount of whitespace can separate tokens.</p>
</section>
<section id="slide-title" class="slide">
<p>Basic Machines</p>
<p>  &#39;simple&#39; - Concatenation literal. Produces a machine that matches the sequence of characters. 6 letters. 7 states include the start state.</p>
<p>  &quot;simple&quot; - same thing</p>
<p>  (picture of machine)</p>
</section>
<section id="slide-title" class="slide">
<p>Union Expression</p>
<p>  [abc] - Produces a union of characters.
  [acm-z] - Ranges are allowed</p>
</section>
<section id="slide-title" class="slide">
<p>Zero Length Machine</p>
<p>  &#39;&#39;
  &quot;&quot;
  []</p>
</section>
<section id="slide-title" class="slide">
<p>Numerical Literal</p>
<p>  42 - Produces a two-state machine with one transition on the given value, which can be given in decimal or hexadecimal.</p>
</section>
<section id="slide-title" class="slide">
<p>Regular Expression</p>
<p>  /fooba[rz]/ - prased as a series of expression concatenated together.
  . (any)
  a* - repetition
  a+ - repetition
  [^abc] - negation
  /FOO/i - case insensitive</p>
</section>
<section id="slide-title" class="slide">
<p>Regular Expression (more complex)</p>
<p>  /ab<em>[c-z].</em>[123]/</p>
<p>  You don&#39;t need fancy regexps because the great Ragel engine allows you to do whatever you would need here. How many turtles do you need?</p>
</section>
<section id="slide-title" class="slide">
<p>Range Expression</p>
<p>  &#39;a&#39;..&#39;z&#39; - produces a machine that matches characters in the range</p>
</section>
<section id="slide-title" class="slide">
<p>Variable Name</p>
<p>  secret_code - lookup the machine named by this and use an instance of it.</p>
</section>
<section id="slide-title" class="slide">
<p>Builtin Machines</p>
<p>  any – Any character in the alphabet.
  ascii – Ascii characters. 0..127
  extend – Ascii extended characters. This is the range -128..127 for signed alphabets and the range 0..255 for unsigned alphabets.
  alpha – Alphabetic characters. [A-Za-z]
  digit - Digits. [0-9]
  alnum – Alpha numerics. [0-9A-Za-z]
  lower – Lowercase characters. [a-z]
  upper – Uppercase characters. [A-Z]
  xdigit - Hexadecimal digits. [0-9A-Fa-f]
  cntrl – Control characters. 0..31
  graph – Graphical characters. [!-~]
  print – Printable characters. [ -~]
  punct – Punctuation. Graphical characters that are not alphanumerics. [!-/:-@[-‘{-~]
  space - Whitespace. [\t\v\f\n\r ]
  zlen - Zero length string. &quot;&quot;
  empty - Empty set. Matches nothing. ^any</p>
</section>
<section id="slide-title" class="slide">
<p>Simple Machines</p>
<ul>
<li>Ok. At this point you are a caveman (or cave woman).</li>
<li>You have some simple machines (lever, inclined plane, wedge, pulley, wheel and axle, screw)</li>
<li>But we don&#39;t have to stop there. We&#39;re not cave people. We&#39;re going to combine these basic machines into better machines so we can travel to the moon</li>
</ul>
</section>
<section id="slide-title" class="slide">
<p>Composition</p>
<ul>
<li>We&#39;re computer scientists.</li>
<li>We develop basic building blocks.</li>
<li>Then we add for loops and arrays to turn them into monstrosities.</li>
<li>Let&#39;s see how to do that.</li>
</ul>
</section>
<section id="slide-title" class="slide">
<p>Regular Language Operators</p>
<ul>
<li>This is the part of Ragel that I found fascinating when I first grokked it.</li>
<li>Ragel&#39;s DSL allows you to take these simple machines, and through some basic operators, combine those into bigger machines, and then combine those into BIGGER machines. Keep going util you have RubyOnRails.</li>
<li>This compositional technique is what gives Ragel it&#39;s extreme simplicity and combinational power. I can&#39;t stress this point enough.</li>
</ul>
</section>
<section id="slide-title" class="slide">
<p>Ragel&#39;s Voodoo</p>
<p>  &quot;To create an epsilon transition between two states x and y is to
  copy all of the properties of y into x. This involves drawing in all
  of y’s to-state actions, EOF actions, etc., in addition to its
  transitions. If x and y both have a transition out on the same
  character, then the transitions must be combined. During transition
  combination a new transition is made that goes to a new state that
  is the combination of both target states. The new combination state
  is created using the same epsilon transition method. The new state
  has an epsilon transition drawn to all the states that compose
  it. Since the creation of new epsilon transitions may be triggered
  every time an epsilon transition is drawn, the process of drawing
  epsilon transitions is repeated until there are no more epsilon
  transitions to be made.</p>
</section>
<section id="slide-title" class="slide">
<p>Compositional Operators
  expr | expr - union
  expr &amp; expr - intersection
  expr - expr - difference
  expr -- expr - strong difference
  expr . expr - concatenation
  expr* - kleene star
  expr+ - one or more repetion
  expr? - optional
  expr{n} - exactly N copies of expr
  expr{n,} - Zero to N copies of expr
  expr{,m} - N or more copies of expr
  expr{n,m} - N to M copies of expr<br>  !expr - negation
  ^expr - character-level negation</p>
</section>
<section id="slide-title" class="slide">
<p>Union</p>
<p>  expr | expr - matches any string in machine one or machine two
  (union pic)</p>
<p>  The operation first creates a new start state. Epsilon transitions are
  drawn from the new start state to the start states of both input
  machines. The resulting machine has a final state set equivalent to
  the union of the final state sets of both input machines. In this
  operation, there is the opportunity for nondeterminism among both
  branches. If there are strings, or prefixes of strings that are
  matched by both machines then the new machine will follow both parts
  of the alternation at once. The union operation is shown below.</p>
</section>
<section id="slide-title" class="slide">
<p>Intersection</p>
<p>  expr &amp; expr - matches any string that is in both machine one and two</p>
<p>  To achieve intersection, a union is performed on the two
  machines. After the result has been made deterministic, any final
  state that is not a combination of final states from both machines
  has its final state status revoked. To complete the operation, paths
  that do not lead to a final state are pruned from the
  machine. Therefore, if there are any such paths in either of the
  expressions they will be removed by the intersection
  operator. Intersection can be used to require that two independent
  patterns be simultaneously satisfied as in the following example.</p>
</section>
<section id="slide-title" class="slide">
<p>Difference</p>
<p>  expr - expr - matches strings in machine one but not in machine two</p>
<p>  To achieve subtraction, a union is performed on the two
  machines. After the result has been made deterministic, any final
  state that came from machine two or is a combination of states
  involving a final state from machine two has its final state status
  revoked. As with intersection, the operation is completed by pruning
  any path that does not lead to a final state. The following example
  demonstrates the use of subtraction to exclude specific cases from a
  set.</p>
</section>
<section id="slide-title" class="slide">
<p>Strong Difference</p>
<p>  expr -- expr - matches any string of the first machine that does not have any string of the second machine as a substring.</p>
<p>  Equivalent to:</p>
<p>  expr - ( any<em> expr any</em> )</p>
<p>  In the following example, strong subtraction is used to excluded
  CRLF from a sequence. In the corresponding visualization, the label
  DEF is short for default. The default transition is taken if no
  other transition can be taken.</p>
</section>
<section id="slide-title" class="slide">
<p>Concatenation</p>
<p>  expr . expr</p>
<p>  Matches all the strings in machine one followed by all the strings in machine two.</p>
<p>  Concatenation draws epsilon transitions from the final states of the
  first machine to the start state of the second machine. The final
  states of the first machine lose their final state status, unless
  the start state of the second machine is final as
  well. Concatenation is the default operator. Two machines next to
  each other with no operator between them results in concatenation.</p>
<p>  DANGER: The opportunity for nondeterministic behaviour results from
  the possibility of the final states of the first machine accepting a
  string that is also accepted by the start state of the second
  machine. The most common scenario in which this happens is the
  concatenation of a machine that repeats some pattern with a machine
  that gives a terminating string, but the repetition machine does not
  exclude the terminating string.</p>
<p>  There are techniques for avoiding this.</p>
</section>
<section id="slide-title" class="slide">
<p>Kleene Star</p>
<p>  expr*</p>
<p>  Match zero or more repetitions of the machine it is applied to.</p>
<p>  It creates a new start state and an additional final state. Epsilon
  transitions are drawn between the new start state and the old start
  state, between the new start state and the new final state, and
  between the final states of the machine and the new start
  state. After the machine is made deterministic the effect is of the
  final states getting all the transitions of the start state.</p>
<p>  DANGER: The possibility for nondeterministic behaviour arises if the
  final states have transitions on any of the same characters as the
  start state.</p>
</section>
<section id="slide-title" class="slide">
<p>One or More Repetion</p>
<p>  expr+</p>
<p>  Produces the concatenation of the machine with the kleene star of
  itself. The result will match one or more repetitions of the
  machine.</p>
<p>  Equivalent to:</p>
<p>  expr . expr*</p>
</section>
<section id="slide-title" class="slide">
<p>Optional</p>
<p>  expr?</p>
<p>  The optional operator produces a machine that accepts the machine
  given or the zero length string. The optional operator is equivalent
  to (expr | ’’ ). In the following example the optional operator is
  used to possibly extend a token.</p>
<p>  Equivlaent to:</p>
<p>  expr | &#39;&#39;</p>
</section>
<section id="slide-title" class="slide">
<p>Repetition</p>
<p>  expr{n} - exactly N copies of expr
  expr{n,} - Zero to N copies of expr
  expr{,m} - N or more copies of expr
  expr{n,m} - N to M copies of expr</p>
</section>
<section id="slide-title" class="slide">
<p>Negation</p>
<p>  !expr</p>
<p>  Negation produces a machine that matches any string not matched by the given machine. Negation is equivalent to (any* - expr).</p>
</section>
<section id="slide-title" class="slide">
<p>Character- Level Negation</p>
<p>  ^expr</p>
<p>  Character-level negation produces a machine that matches any single
  character not matched by the given machine. Character-Level Negation
  is equivalent to (any - expr). It must be applied only to machines
  that match strings of length one.</p>
</section>
<section id="slide-title" class="slide">
<p>State Machine Minimiztion</p>
<p>  &quot;Reduces the number of states in machines by merging equivalent
  states. It does not change the behaviour of the machine in any
  way. It will cause some states to be merged into one because they
  are functionally equivalent. State minimization is on by default. It
  can be turned off with the -n option.&quot;</p>
</section>
<section id="slide-title" class="slide">
<p>Visualization</p>
<p>  ragel -V simple.rl &gt; simple.dot</p>
<p>  dot -Tsvg simple.dot -o simple.svg</p>
<p>  If the final graph is too large to be meaningful, or even drawn, the
  user is able to inspect portions of the parser by naming particular
  regular expression definitions with the -S and -M options to the
  ragel program. Use of Graphviz greatly improves the Ragel
  programming experience. It allows users to learn Ragel by
  experimentation and also to track down bugs caused by unintended
  nondeterminism.  Ragel has another option to help debugging. The -x
  option causes Ragel to emit the compiled machine in an XML format.</p>
</section>
<section id="slide-title" class="slide">
<p>User Actions</p>
<p>  Composition is definitely cool and useful. But on top of that, Ragel
  gives you embedded actions. This is where you take all the
  composition and really make it sing, on key.</p>
</section>
<section id="slide-title" class="slide">
<p>Embedding Actions</p>
<p>  action <action_name> {</p>
<pre><code><span class="hljs-comment"># host code here</span>
<span class="hljs-command">count</span> += <span class="hljs-number">1</span>
</code></pre><p>  }</p>
<p>  Actions can be referenced by name or embedded inline.</p>
</section>
<section id="slide-title" class="slide">
<p>Transitions</p>
<p>  Transitions come in four classes, and actions can be attached to any of them.</p>
</section>
<section id="slide-title" class="slide">
<p>Entering Transition</p>
<blockquote>
<p>operator</p>
</blockquote>
<p>  expr &gt; action_name
  expr &gt;{ puts &quot;entering&quot; }</p>
<p>  Embeds an action into all transitions leaving the &quot;start state&quot;</p>
</section>
<section id="slide-title" class="slide">
<p>Finishing Transition</p>
<p>  @ operator</p>
<p>  expr @ action_name
  expr @{ puts &quot;finishing&quot; }</p>
<p>  Embeds an action into all transitions going into a &quot;final state&quot;</p>
</section>
<section id="slide-title" class="slide">
<p>All Transition</p>
<p>  $ operator</p>
<p>  expr $ action_name
  expr ${ puts &quot;transitioned&quot; }</p>
<p>  Embeds an action into all transitions, regardless of type (useful for debugging).</p>
</section>
<section id="slide-title" class="slide">
<p>Leaving Transition</p>
<p>  % operator
  expr % action_name
  expr %{ puts &quot;leaving&quot; }</p>
<p>  Embeds an action into all transitions leaving the machine from a &quot;final state&quot;</p>
</section>
<section id="slide-title" class="slide">
<p>Embedding Operators Can Get Fancy</p>
<p>  The different classes of states are:</p>
<pre><code>&gt; – <span class="hljs-operator">the</span> <span class="hljs-built_in">start</span> state
&lt; – <span class="hljs-keyword">any</span> state except <span class="hljs-operator">the</span> <span class="hljs-built_in">start</span> state
$ – all states
% – final states
@ – <span class="hljs-keyword">any</span> state except final states
&lt;&gt; – <span class="hljs-keyword">any</span> except <span class="hljs-built_in">start</span> <span class="hljs-operator">and</span> final (<span class="hljs-keyword">middle</span>)
</code></pre><p>  The different kinds of embeddings are:
    ~ – to-state actions (to)</p>
<pre><code>* – <span class="hljs-keyword">from</span>-state actions (<span class="hljs-keyword">from</span>)
/ – EOF actions (eof)
! – <span class="hljs-keyword">error</span> actions (err)
^ – <span class="hljs-keyword">local</span> <span class="hljs-keyword">error</span> actions (lerr)
</code></pre>
</section>
<section id="slide-title" class="slide">
<p>To-State Actions</p>
<pre><code>&gt;~action    &gt;to(name)    &gt;to<span class="hljs-decorator">{...}</span>    - the start state
&lt;~action    &lt;to(name)    &lt;to<span class="hljs-decorator">{...}</span>    - <span class="hljs-type">any</span> tate <span class="hljs-keyword">except</span> the start state
$~action    $to(name)    $to<span class="hljs-decorator">{...}</span>    - all states
%~action    %to(name)    %to<span class="hljs-decorator">{...}</span>    - final states
@~action    @to(name)    @to<span class="hljs-decorator">{...}</span>    - <span class="hljs-type">any</span> state <span class="hljs-keyword">except</span> final states
&lt;&gt;~action   &lt;&gt;to(name)   &lt;&gt;to<span class="hljs-decorator">{...}</span>   - <span class="hljs-type">any</span> <span class="hljs-keyword">except</span> start <span class="hljs-keyword">and</span> final (middle)
</code></pre><p>   To-state actions are executed whenever the state machine moves into
   the specified state, either by a natural movement over a transition
   or by an action-based transfer of control such as fgoto. They are
   executed after the in-transition’s actions but before the current
   character is advanced and tested against the end of the input
   block. To-state embeddings stay with the state. They are
   irrespective of the state’s current set of transitions and any
   future transitions that may be added in or out of the state.</p>
</section>
<section id="slide-title" class="slide">
<p>From-State Actions</p>
<pre><code>&gt;*action    &gt;<span class="hljs-keyword">from</span>(name)    &gt;<span class="hljs-keyword">from</span><span class="hljs-decorator">{...}</span>    – the start state                    
&lt;*action    &lt;<span class="hljs-keyword">from</span>(name)    &lt;<span class="hljs-keyword">from</span><span class="hljs-decorator">{...}</span>    – <span class="hljs-type">any</span> state <span class="hljs-keyword">except</span> the start state   
$*action    $<span class="hljs-keyword">from</span>(name)    $<span class="hljs-keyword">from</span><span class="hljs-decorator">{...}</span>    – all states                         
%*action    %<span class="hljs-keyword">from</span>(name)    %<span class="hljs-keyword">from</span><span class="hljs-decorator">{...}</span>    – final states                       
@*action    @<span class="hljs-keyword">from</span>(name)    @<span class="hljs-keyword">from</span><span class="hljs-decorator">{...}</span>    – <span class="hljs-type">any</span> state <span class="hljs-keyword">except</span> final states      
&lt;&gt;*action   &lt;&gt;<span class="hljs-keyword">from</span>(name)   &lt;&gt;<span class="hljs-keyword">from</span><span class="hljs-decorator">{...}</span>   – <span class="hljs-type">any</span> <span class="hljs-keyword">except</span> start <span class="hljs-keyword">and</span> final (middle)
</code></pre><p>  See the user guide for more detail.</p>
<p>  From-state actions are executed whenever the state machine takes a
  transition from a state.  either to itself or to some other
  state. These actions are executed immediately after the current
  character is tested against the input block end marker and before
  the transition to take is sought based on the current
  character. From-state actions are therefore executed even if a
  transition cannot be found and the machine moves into the error
  state. Like to-state embeddings, from-state embeddings stay with the
  state.</p>
</section>
<section id="slide-title" class="slide">
<p>EOF Actions</p>
<blockquote>
<p>/action   &gt;eof(name)    &gt;eof{...}    – the start state<br>   </action   <eof(name)    <eof{...}    – any state except the start state   
   $/action   $eof(name)    $eof{...}    – all states                         
   %/action   %eof(name)    %eof{...}    – final states                       
   @/action   @eof(name)    @eof{...}    – any state except final states      
   <>/action  &lt;&gt;eof(name)   &lt;&gt;eof{...}   – any except start and final (middle)</p>
</blockquote>
<p>  The EOF action embedding operators enable the user to embed actions
  that are executed at the end of the input stream. EOF actions are
  stored in states and generated in the write exec block. They are run
  when p == pe == eof as the execute block is finishing. EOF actions
  are free to adjust p and jump to another part of the machine to
  restart execution.</p>
</section>
<section id="slide-title" class="slide">
<p>Global Error Actions</p>
<blockquote>
<p>!action   &gt;err{...}   &gt;err{...}   – the start state<br>  &lt;!action   <err{...}   <err{...}   – any state except the start state  
  $!action   $err{...}   $err{...}   – all states                        
  %!action   %err{...}   %err{...}   – final states
  @!action   @err(name)  @err{...}   – any state except final states
  <>!action  &lt;&gt;err(name) &lt;&gt;err{...}  – any except start and final (middle)</p>
</blockquote>
<p>  Global error actions are stored in the states they are embedded into
  until compilation is com- plete. They are then transferred to the
  transitions that move into the error state. These transitions are
  taken on all input characters that are not already covered by the
  state’s transitions. If a state with an error action is not final
  when compilation is complete, then the action is also embedded as an
  EOF action.  Error actions can be used to recover from errors by
  jumping back into the machine with fgoto and optionally altering p.</p>
</section>
<section id="slide-title" class="slide">
<p>Local Error Actions</p>
<blockquote>
<p>^action   &gt;lerr(name)   &gt;lerr{...}    – the start state<br>  &lt;^action   <lerr(name)   <lerr{...}    – any state except the start state   
  $^action   $lerr(name)   $lerr{...}    – all states                         
  %^action   %lerr(name)   %lerr{...}    – final states                       
  @^action   @lerr(name)   @lerr{...}    – any state except final states      
  <>^action  &lt;&gt;lerr(name)  &lt;&gt;lerr{...}   – any except start and final (middle)</p>
</blockquote>
<p>  Like global error actions, local error actions are also stored in
  the states they are embedded into until a transfer point. The
  transfer point is different however. Each local error action
  embedding is associated with a name. When a machine definition has
  been fully constructed, all local error action embeddings associated
  with the same name as the machine definition are transferred to the
  error transitions. At this time they are also embedded as EOF
  actions in the case of non-final states.  Local error actions can be
  used to specify an action to take when a particular section of a
  larger state machine fails to match. A particular machine
  definition’s “thread” may die and the local error actions executed,
  however the machine as a whole may continue to match input.  There
  are two forms of local error action embeddings. In the first form
  the name defaults to the current machine. In the second form the
  machine name can be specified. This is useful when it is more
  convenient to specify the local error action in a sub-definition
  that is used to construct the machine definition that the local
  error action is associated with. To embed local error actions and
  explicitly state the machine definition on which the transfer is to
  happen use (name, action) as the action.</p>
</section>
<section id="slide-title" class="slide">
<p>Error Action Example</p>
<p>   action cmd_err {
       printf( &quot;command error\n&quot; );
       fhold; fgoto line;
   }</p>
<p>   action from_err {
       printf( &quot;from error\n&quot; );
       fhold; fgoto line;
   }</p>
<p>   action to_err {
       printf( &quot;to error\n&quot; );
       fhold; fgoto line;
   }</p>
<p>   line := [^\n]* &#39;\n&#39; @{ fgoto main; };</p>
<p>   main := (
     (
       &#39;from&#39; @err(cmd_err)
           ( ws+ address ws+ date &#39;\n&#39; ) $err(from_err) |
       &#39;to&#39; @err(cmd_err)
           ( ws+ address &#39;\n&#39; ) $err(to_err)
     )
   )*;</p>
</section>
<section id="slide-title" class="slide">
<p>Parser Internals</p>
<p>  A number of different variables and statements can be adjusted or used to examine and influence the state of the parser.</p>
<p>  fpc – A pointer to the current character. This is equivalent to accessing the p variable.</p>
<p>  fc – The current character. This is equivalent to the expression (*p).</p>
<p>  fcurs – An integer value representing the current state. This value
  should only be read from. To move to a different place in the
  machine from action code use the fgoto, fnext or fcall
  statements. Outside of the machine execution code the cs variable
  may be modified.</p>
<p>  ftargs – An integer value representing the target state. This value
  should only be read from. Again, fgoto, fnext and fcall can be used
  to move to a specific entry point.</p>
<p>  fentry(<label>) – Retrieve an integer value representing the entry
  point label. The integer value returned will be a compile time
  constant. This number is suitable for later use in control flow
  transfer statements that take an expression. This value should not
  be compared against the current state because any given label can
  have multiple states representing it. The value returned by fentry
  can be any one of the multiple states that it represents.  The
  following statements are available in code blocks:</p>
<p>  fhold; – Do not advance over the current character. If processing
  data in multiple buffer blocks, the fhold statement should only be
  used once in the set of actions executed on a character. Multiple
  calls may result in backing up over the beginning of the buffer
  block. The fhold statement does not imply any transfer of
  control. It is equivalent to the p--; statement.</p>
<p>  fexec <expr>; – Set the next character to process. This can be used
  to backtrack to previous input or advance ahead. Unlike fhold, which
  can be used anywhere, fexec requires the user to ensure that the
  target of the backtrack is in the current buffer block or is known
  to be somewhere ahead of it. The machine will continue iterating
  forward until pe is arrived at, fbreak is called or the machine
  moves into the error state. In actions embedded into transitions,
  the fexec statement is equivalent to setting p to one position ahead
  of the next character to process. If the user also modifies pe, it
  is possible to change the buffer block entirely.</p>
<p>  fgoto <label>; – Jump to an entry point defined by <label>. The
  fgoto statement imme- diately transfers control to the destination
  state.</p>
<p>  fgoto *<expr>; – Jump to an entry point given by <expr>. The
  expression must evaluate to an integer value representing a state.</p>
<p>  fnext <label>; – Set the next state to be the entry point defined by
  label. The fnext statement does not immediately jump to the
  specified state. Any action code following the statement is
  executed.</p>
<p>  fnext *<expr>; – Set the next state to be the entry point given by
  <expr>. The expression must evaluate to an integer value
  representing a state.</p>
<p>  fcall <label>; – Push the target state and jump to the entry point
  defined by <label>. The next fret will jump to the target of the
  transition on which the call was made. Use of fcall requires the
  declaration of a call stack. An array of integers named stack and a
  single integer named top must be declared. With the fcall construct,
  control is immediately transferred to the destination state. See
  section 6.1 for more information.</p>
<p>  fcall *<expr>; – Push the current state and jump to the entry point
  given by <expr>. The expression must evaluate to an integer value
  representing a state.</p>
<p>  fret; – Return to the target state of the transition on which the
  last fcall was made. Use of fret requires the declaration of a call
  stack. Control is immediately transferred to the destination state.</p>
<p>  fbreak; – Advance p, save the target state to cs and immediately
  break out of the execute loop. This statement is useful in
  conjunction with the noend write option. Rather than process input
  until pe is arrived at, the fbreak statement can be used to stop
  processing from an action. After an fbreak statement the p variable
  will point to the next character in the input. The current state
  will be the target of the current transition. Note that fbreak
  causes the target state’s to-state actions to be skipped.</p>
</section>
<section id="slide-title" class="slide">
<p>Nondeterminism</p>
<p>   One of the problems you will run into is when the trailing match of
   one machine is the same as the leading match of the next
   machine. In these cases, the state will be stuck in the first
   machine and never transition to the next machine.</p>
<p>   Example:</p>
<pre><code> ws = [\n\t ];
 line = word <span class="hljs-variable">$first</span> ( ws word <span class="hljs-variable">$tail</span> )* ’\n’;
 lines = line*;
</code></pre><p>   Since the ws expression includes the newline character, we will not finish the line expression when a newline character is seen.</p>
<p>   The solution here is simple: exclude the newline character from the ws expression.</p>
<pre><code> ws = [\t ];
 line = word <span class="hljs-variable">$first</span> ( ws word <span class="hljs-variable">$tail</span> )* ’\n’;
 lines = line*;
</code></pre>
</section>
<section id="slide-title" class="slide">
<p>Ambiguity Problems</p>
<p>  Solving this kind of problem is straightforward when the ambiguity
  is created by strings that are a single character long. When the
  ambiguity is created by strings that are multiple characters long we
  have a more difficult problem. The following example is an incorrect
  attempt at a regular expression for C language comments.</p>
</section>
<section id="slide-title" class="slide">
<p>The Wrong Way</p>
<pre><code>  <span class="hljs-title">comment</span> = ’/*’ ( any <span class="hljs-variable">@comm</span> )* ’*/’;
  <span class="hljs-title">main</span> := comment ’ ’;
</code></pre>
</section>
<section id="slide-title" class="slide">
<p>Verbose But Proper:</p>
<pre><code>  comment = ’/*’ ( ( any @comm )* - ( any* ’*/’ any* ) ) ’*/’;

One way <span class="hljs-keyword">to</span> approach <span class="hljs-keyword">the</span> problem <span class="hljs-keyword">is</span> <span class="hljs-keyword">to</span> exclude <span class="hljs-keyword">the</span> terminating
<span class="hljs-type">string</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">the</span> any* expression using <span class="hljs-keyword">set</span> difference. We must be
careful <span class="hljs-keyword">to</span> exclude <span class="hljs-keyword">not</span> just <span class="hljs-keyword">the</span> terminating <span class="hljs-type">string</span>, <span class="hljs-keyword">but</span> any <span class="hljs-type">string</span>
<span class="hljs-keyword">that</span> <span class="hljs-keyword">contains</span> <span class="hljs-keyword">it</span> <span class="hljs-keyword">as</span> a substring. A verbose, <span class="hljs-keyword">but</span> proper
specification <span class="hljs-keyword">of</span> a C comment parser <span class="hljs-keyword">is</span> <span class="hljs-keyword">given</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> following
regular expression.
</code></pre>
</section>
<section id="slide-title" class="slide">
<p>This Is Complicated!</p>
<pre><code>Note that Ragel’s strong subtraction operator <span class="hljs-comment">-- can also be used</span>
here. In doing this subtraction we have phrased <span class="hljs-operator">the</span> problem <span class="hljs-operator">of</span>
controlling non-determinism <span class="hljs-operator">in</span> terms <span class="hljs-operator">of</span> excluding strings common
<span class="hljs-built_in">to</span> <span class="hljs-constant">two</span> expressions that interact when combined. We can also phrase
<span class="hljs-operator">the</span> problem <span class="hljs-operator">in</span> terms <span class="hljs-operator">of</span> <span class="hljs-operator">the</span> transitions <span class="hljs-operator">of</span> <span class="hljs-operator">the</span> state machines that
implement these expressions.
</code></pre>
</section>
<section id="slide-title" class="slide">
<p>There Are Better Ways</p>
<p>  We can embed priorities into certain transistions to deal with this ambiguity. Ragel gives us some nice ways to do this.</p>
</section>
<section id="slide-title" class="slide">
<p>If only there were some short-hand operators we could use here.</p>
</section>
<section id="slide-title" class="slide">
<p>Setting Priorities Manually</p>
<p>  expr &gt; int – Sets starting transitions to have priority int.</p>
<p>  expr @ int – Sets transitions that go into a final state to have priority int.</p>
<p>  expr $ int – Sets all transitions to have priority int.</p>
<p>  expr % int – Sets leaving transitions to have priority int. When a
  transition is made going out of the machine (either by concatenation
  or kleene star) its priority is immediately set to the leaving
  priority.</p>
</section>
<section id="slide-title" class="slide">
<p>Namespacing Priorities</p>
<p>  When machines are combined, you can get odd interactions if you
  don&#39;t namespace the priorities.</p>
<p>  expr &gt; (name, int) – Starting transitions.
  expr @ (name, int) – Finishing transitions (into a final state).
  expr $ (name, int) – All transitions.
  expr % (name, int) – Leaving transitions.</p>
</section>
<section id="slide-title" class="slide">
<p>Guarded Operations</p>
<p>  Priority embeddings are a very expressive mechanism. At the same
  time they can be very confusing for the user. They force the user to
  imagine the transitions inside two interacting expressions and work
  out the precise effects of the operations between them. When we
  consider that this problem is worsened by the potential for side
  effects caused by unintended priority name collisions, we see that
  exposing the user to priorities is undesirable.</p>
</section>
<section id="slide-title" class="slide">
<p>Finish-Guarded Concatenation</p>
<p>  A higher priority is then embedded into the transitions of the second machine that enter into a final state.</p>
<pre><code>comment = ’/*’ ( any <span class="hljs-variable">@comm</span> )* <span class="hljs-symbol">:&gt;&gt;</span> ’*<span class="hljs-regexp">/’;</span>
</code></pre><p>  This is much simpler to visualize and reason about.</p>
</section>
<section id="slide-title" class="slide">
<p>Entry-Guarded Concatenation</p>
<p>  expr :&gt; expr</p>
<p>  Assigns a low priority to all transitions of the first machine and a high priority to the starting transitions of the second machine.</p>
<pre><code><span class="hljs-comment"># Leave the catch-all machine on the first character of FIN.</span>
main <span class="hljs-symbol">:</span>= any* <span class="hljs-symbol">:&gt;</span> <span class="hljs-string">'FIN'</span>;
</code></pre><p>  Equivalent to:</p>
<pre><code>expr $(unique_name,<span class="hljs-number">0</span>) . expr &gt;(unique_name,<span class="hljs-number">1</span>)
</code></pre>
</section>
<section id="slide-title" class="slide">
<p>Finish-Guarded Concatenation</p>
<p>  expr :&gt;&gt; expr</p>
<p>  Higher priority is placed on the final transitions of the second
  machine. This is useful if one wishes to entertain the possibility
  of continuing to match the first machine right up until the second
  machine enters a final state. It terminates the first machine only
  when the second accepts. In the following example, finish-guarded
  concatenation causes the move out of the machine that matches
  everything to be delayed until the full end-of-input marker has been
  matched.</p>
<h1>Leave the catch-all machine on the last character of FIN.</h1><p>  main := any* :&gt;&gt; ’FIN’;</p>
<p>  Finish-guarded concatenation is equivalent to the following, with
  one exception. If the right machine’s start state is final, the
  higher priority is also embedded into it as a leaving priority. This
  prevents the left machine from persisting via the zero-length
  string.</p>
<p>  expr $(unique_name,0) . expr @(unique_name,1)</p>
</section>
<section id="slide-title" class="slide">
<p>Left-Guarded Concatenation</p>
<p>  expr &lt;: expr</p>
<p>  This operator places a higher priority on the left expression. It is
  useful if you want to prefix a sequence with another sequence
  composed of some of the same characters. For example, one can
  consume leading whitespace before tokenizing a sequence of
  whitespace-separated words as in:</p>
<pre><code>main := ( ’ ’* &gt;<span class="hljs-keyword">start</span> <span class="hljs-decorator">%fin</span> ) &lt;: ( ’ ’ <span class="hljs-variable">$ws</span> | [a-z] <span class="hljs-variable">$alpha</span> )*;
</code></pre><p>  Left-guarded concatenation is equivalent to the following:</p>
<pre><code>expr $(unique_name,<span class="hljs-number">1</span>) . expr &gt;(unique_name,<span class="hljs-number">0</span>)
</code></pre>
</section>
<section id="slide-title" class="slide">
<p>Longest-Match Kleene Star</p>
<p>  expr**</p>
<p>  This version of kleene star puts a higher priority on staying in the
  machine versus wrapping around and starting over. The LM kleene star
  is useful when writing simple tokenizers. These machines are built
  by applying the longest-match kleene star to an alternation of token
  patterns, as in the following.</p>
<pre><code><span class="hljs-comment"># Repeat tokens, but make sure to get the longest match.</span>
Main := (
  lower ( lower |<span class="hljs-string"> digit )* %A </span>|<span class="hljs-string"> digit+ %B </span>|
  ''
)<span class="hljs-keyword">*</span><span class="hljs-keyword">*</span>;
</code></pre><p>  If a regular kleene star were used the machine above would not be
  able to distinguish between extending a word and beginning a new
  one. This operator is equivalent to:</p>
<pre><code><span class="hljs-list">( <span class="hljs-keyword">expr</span> $<span class="hljs-list">(<span class="hljs-keyword">unique_name</span>,<span class="hljs-number">1</span>)</span> %<span class="hljs-list">(<span class="hljs-keyword">unique_name</span>,<span class="hljs-number">0</span>)</span> )</span>*
</code></pre><p>  Note that this operator does not build a scanner in the traditional
  sense because there is never any backtracking. To build a scanner
  with backtracking use the Longest-Match machine construction
  described in</p>
<p>  We have a better way to do that.</p>
</section>
<section id="slide-title" class="slide">
<p>Parser Modularization</p>
<p>  As your Ragel files get big, you&#39;ll want to start doing some
  modularizaiton. You can create sub-parsers that you can call and
  return from using fcall and fret.</p>
<pre><code><span class="hljs-atom">action</span> <span class="hljs-atom">return</span> { <span class="hljs-atom">fret</span>; }
<span class="hljs-atom">action</span> <span class="hljs-atom">call_date</span> { <span class="hljs-atom">fcall</span> <span class="hljs-atom">date</span>; }
<span class="hljs-atom">action</span> <span class="hljs-atom">call_name</span> { <span class="hljs-atom">fcall</span> <span class="hljs-atom">name</span>; }

# <span class="hljs-name">A</span> <span class="hljs-atom">parser</span> <span class="hljs-atom">for</span> <span class="hljs-atom">date</span> <span class="hljs-atom">strings</span>.
<span class="hljs-atom">date</span> := [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>] <span class="hljs-string">'/'</span>
        [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>] <span class="hljs-string">'/'</span>
        [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>] <span class="hljs-string">'\n'</span> @<span class="hljs-atom">return</span>;

# <span class="hljs-name">A</span> <span class="hljs-atom">parser</span> <span class="hljs-atom">for</span> <span class="hljs-atom">name</span> <span class="hljs-atom">strings</span>.
<span class="hljs-atom">name</span> := ( [<span class="hljs-atom">a</span>-<span class="hljs-atom">zA</span>-<span class="hljs-name">Z</span>]+ | <span class="hljs-string">' '</span> )** <span class="hljs-string">'\n'</span> @<span class="hljs-atom">return</span>;

# <span class="hljs-name">The</span> <span class="hljs-atom">main</span> <span class="hljs-atom">parser</span>.
<span class="hljs-atom">headers</span> =
    ( <span class="hljs-string">'from'</span> | <span class="hljs-string">'to'</span> ) <span class="hljs-string">':'</span> @<span class="hljs-atom">call_name</span> |
    ( <span class="hljs-string">'departed'</span> | <span class="hljs-string">'arrived'</span> ) <span class="hljs-string">':'</span> @<span class="hljs-atom">call_date</span>;

<span class="hljs-atom">main</span> := <span class="hljs-atom">headers</span>*;
</code></pre><p>  Calling and jumping should be used carefully as they are operations
  that take one out of the domain of regular languages. This is when
  you need to start thinking carefully about the structure of your
  parser.</p>
<p>  This is very powerful, however. For example, you could use this to
  parse strings in ruby in strings in ruby if you are careful to keep
  a stack of your context as you go along.</p>
</section>
<section id="slide-title" class="slide">
<p>Scanners</p>
<ul>
<li><p>Uses longest-match semantics to continually process input</p>
<p>%%{</p>
<p> machine test_lexer;</p>
<p> <scanner_name> := |<em>
   <token_description> =&gt; {<action>};
   <token_description> =&gt; {<action>};
 </em>|;</p>
<p>}%%</p>
<p>Since scanners are such a common thing to build when doing this type
of parsing, Ragel provides some convenience syntax for this.</p>
<p><machine_name> := |<em>
  pattern1 =&gt; action1;
  pattern2 =&gt; action2;
  ...
</em>|;</p>
<p>On the surface, Ragel scanners are similar to those defined by
Lex. Though there is a key distinguishing feature: patterns may be
arbitrary Ragel expressions and can therefore contain embedded
code. With a Ragel-based scanner the user need not wait until the
end of a pattern before user code can be executed.</p>
<p>Scanners can be used to process sub-languages, as well as for
tokenizing programming languages. In the following example a scanner
is used to tokenize the contents of a header field.</p>
<p>word = [a-z]+;
head_name = &#39;Header&#39;;
header := |*</p>
<pre><code><span class="hljs-property">word</span>;
</code></pre><p>&#39; &#39;;</p>
<pre><code><span class="hljs-string">'\n'</span> =&gt; { fret; };
</code></pre><p><em>|;
main := ( head_name &#39;:&#39; @{ fcall header; } )</em>;  </p>
<p>The scanner construction has a purpose similar to the longest-match
kleene star operator **. The key difference is that a scanner is
able to backtrack to match a previously matched shorter string when
the pursuit of a longer string fails. For this reason the scanner
construction operator is not a pure state machine construction
operator. It relies on several variables that enable it to backtrack
and make pointers to the matched input text available to the
user. For this reason scanners must be immediately
instantiated. They cannot be defined inline or referenced by another
expression. Scanners must be jumped to or called.</p>
<p>Scanners rely on the ts, te and act variables to be present so that
they can backtrack and make pointers to the matched text available
to the user. If input is processed using multiple calls to the
execute code then the user must ensure that when a token is only
partially matched that the prefix is preserved on the subsequent
invocation of the execute code.</p>
<p>The ts variable must be defined as a pointer to the input data. It
is used for recording where the current token match begins. This
variable may be used in action code for retrieving the text of the
current match. Ragel ensures that in between tokens and outside of
the longest-match machines that this pointer is set to null. In
between calls to the execute code the user must check if ts is set
and if so, ensure that the data it points to is preserved ahead of
the next buffer block. This is described in more detail below.</p>
<p>The te variable must also be defined as a pointer to the input
data. It is used for recording where a match ends and where scanning
of the next token should begin. This can also be used in action code
for retrieving the text of the current match.</p>
<p>The act variable must be defined as an integer type. It is used for
recording the identity of the last pattern matched when the scanner
must go past a matched pattern in an attempt to make a longer
match. If the longer match fails it may need to consult the act
variable. In some cases, use of the act variable can be avoided
because the value of the current state is enough information to
determine which token to accept, however in other cases this is not
enough and so the act variable is used.</p>
</li>
</ul>
</section>
<section id="slide-title" class="slide">
<p>Scanner Variables
  (include pic from pdf)</p>
<p>  ts
  te
  action</p>
</section>
<section id="slide-title" class="slide">
<p>State Charts</p>
<p>  In addition to supporting the construction of state machines using
  regular languages, Ragel provides a way to manually specify state
  machines using state charts. The comma operator combines machines
  together without any implied transitions. The user can then manually
  link machines by specifying epsilon transitions with the -&gt;
  operator. Epsilon transitions are drawn between the final states of
  a machine and entry points defined by labels. This makes it possible
  to build machines using the explicit state-chart method while making
  minimal changes to the Ragel language.  An interesting feature of
  Ragel’s state chart construction method is that it can be mixed
  freely with regular expression constructions. A state chart may be
  referenced from within a regular expression, or a regular expression
  may be used in the definition of a state chart transition.</p>
</section>
<section id="slide-title" class="slide">
<p>Join</p>
<p>  expr , expr , ...</p>
<p>  Join a list of machines together without drawing any transitions,
  without setting up a start state, and without designating any final
  states. Transitions between the machines may be specified using
  labels and epsilon transitions. The start state must be explicity
  specified with the “start” label. Final states may be specified with
  an epsilon transition to the implicitly created “final” state. The
  join operation allows one to build machines using a state chart
  model.</p>
</section>
<section id="slide-title" class="slide">
<p>Label</p>
<p>  label: expr</p>
<p>  Attaches a label to an expression. Labels can be used as the target
  of epsilon transitions and explicit control transfer statements such
  as fgoto and fnext in action code.</p>
</section>
<section id="slide-title" class="slide">
<p>Epsilon</p>
<p>  expr -&gt; label</p>
<p>  Draws an epsilon transition to the state defined by label. Epsilon
  transitions are made deter- ministic when join operators are
  evaluated. Epsilon transitions that are not in a join operation are
  made deterministic when the machine definition that contains the
  epsilon is complete. See Section 6.2 for information on referencing
  labels.</p>
</section>
<section id="slide-title" class="slide">
<p>Dropping Down One Level of Abstraction</p>
<p>  Ragel is that it permits us to bypass the regular language
  abstraction if we need to. Ragel’s action embedding operators are
  sometimes insufficient for expressing certain parsing tasks. In the
  same way that is useful for C language programmers to drop down to
  assembly language programming using embedded assembler, it is
  sometimes useful for the Ragel programmer to drop down to
  programming with state charts.</p>
<pre><code>action bchar { buff( fpc ); }
action bbrack1 { buff( <span class="hljs-string">"]"</span> ); }
action bbrack2 { buff( <span class="hljs-string">"]]"</span> ); }
CDATA_body =
<span class="hljs-attribute">start</span>: (
<span class="hljs-string">']'</span><span class="hljs-function"> -&gt;</span> one |
     (any-<span class="hljs-string">']'</span>) <span class="hljs-property">@bchar</span><span class="hljs-function"> -&gt;</span>start
),
<span class="hljs-attribute">one</span>: (
     <span class="hljs-string">']'</span><span class="hljs-function"> -&gt;</span> two |
     [^<span class="hljs-string">\]]</span> <span class="hljs-property">@bbrack1</span> <span class="hljs-property">@bchar</span><span class="hljs-function"> -&gt;</span>start
),
<span class="hljs-attribute">two</span>: (
     <span class="hljs-string">'&gt;'</span><span class="hljs-function"> -&gt;</span> final |
     <span class="hljs-string">']'</span> <span class="hljs-property">@bbrack1</span><span class="hljs-function"> -&gt;</span> two |
     [^&gt;<span class="hljs-string">\]]</span> <span class="hljs-property">@bbrack2</span> <span class="hljs-property">@bchar</span><span class="hljs-function"> -&gt;</span>start
);
</code></pre>
</section>
<section id="slide-title" class="slide">
<p>Semantic Conditions</p>
<p>  A semantic condition is a block of user code that is interpreted as
  an expression and evaluated immediately before a transition is
  taken. If the code returns a value of true, the transition may be
  taken. We can now embed code that extracts the length of a field,
  then proceed to match n data values.</p>
<pre><code>action <span class="hljs-name">rec_num</span> { i = <span class="hljs-number">0</span>; n = getnumber(); }
<span class="hljs-name">action</span> <span class="hljs-name">test_len</span> { i++ &lt; n }
<span class="hljs-name">data_fields</span> = (
    <span class="hljs-string">'d'</span>
    [0-9]+ %rec_num
    <span class="hljs-string">':'</span>
    ( [a-z] when test_len )*
)**;
</code></pre>
</section>
<section id="slide-title" class="slide">
<p>Implementing Lookahead</p>
<p>  fhold</p>
</section>
<section id="slide-title" class="slide">
<p>Parsing Recursive Structures</p>
<p>  In general Ragel cannot handle recursive structures because the
  grammar is interpreted as a regular language. However, depending on
  what needs to be parsed it is sometimes practical to implement the
  recursive parts using manual coding techniques. This often works in
  cases where the recursive structures are simple and easy to
  recognize, such as in the balancing of parentheses</p>
<pre><code>fcall<span class="hljs-comment">;</span>
fret<span class="hljs-comment">;</span>
</code></pre><p>  The general trick is to store some context about where you are in
  your recursive structure, say in a stack called @nestings, and
  push/pop to it as appropriate. When it comes time to fret, you can
  examine your @nestings and steer the parser as deemed appropriate.</p>
</section>
<section id="slide-title" class="slide">
<p>Installation</p>
<p>  brew install ragel</p>
</section>
<section id="slide-title" class="slide">
<p>Host Language</p>
<p>  simple.rl -&gt; simple.rb</p>
<p>  ragel -R simle.rl -o simple.rb</p>
</section>
<section id="slide-title" class="slide">
<p>To run on a single buffer of String data:</p>
<p>   def ragel_parse(data)
     data = data.unpack(&quot;c*&quot;)
     eof = data.length
     tokens = []</p>
<pre><code><span class="xml"></span><span class="perl"> <span class="hljs-variable">%%</span> <span class="hljs-keyword">write</span> init;</span><span class="xml">
</span><span class="perl"> <span class="hljs-variable">%%</span> <span class="hljs-keyword">write</span> <span class="hljs-keyword">exec</span>;</span><span class="xml">

 puts tokens.inspect</span>
</code></pre><p>   end</p>
</section>
<section id="slide-title" class="slide">
<p>TODO: Walk through the generated ‘hello’ file line by line and explain what is going on (data jump tables, start/end states, execution code)</p>
</section>
<section id="slide-title" class="slide">
<p>How does it work?
1) starts in state 0
2) characters move it through a state
3) it consumes p -&gt; pe from data
4) if cs is &gt;= first_final_state (final states are last) then you have “admitted” the string</p>
<p>ragel -R parser.rl &amp;&amp; ruby parser.rb</p>
</section>
<section id="slide-title" class="slide">
<p>Scanners are a bit more involved, but not that much:
1) use a stack to track states?
2) use ts -&gt; te to track where they are in a match
3) use the stack to backtrack when necessary
4) keep matching thing until we are done
5) helper methods (emit, current_buffer, etc… (from goruby)</p>
</section>
<section id="slide-title" class="slide">
<p>At this point the watcher will be able to create regex-like parsers that can either admit or reject a string. Useful for many things, but there&#39;s so much more!</p>
</section>
<section id="slide-title" class="slide">
<p>We&#39;ll next talk about embedding custom actions into machine states and transitions, and ways to achieve fine-grained flow-control not possible with regexs. We&#39;ll learn how to manipulate the machine&#39;s registers to achieve things like look-ahead, recursive-descent, looping, and more. We&#39;ll get fancy and simpler at the same time by using transition priorities to either achieve or resist early-exit from a pattern.</p>
</section>
<section id="slide-title" class="slide">
<p>Last but not least, we&#39;ll learn how to drop down into the &quot;assembly language&quot; of Ragel -- states and transitions -- in order to specify fully-custom state-machines whose specification lies outside even the compositional language of Ragel&#39;s standard syntax.</p>
</section>
<section id="slide-title" class="slide">
<p>We will finish off the talk with some real-world examples of both simple and complex machines, as well as an overview of how to use the Ragel command line tools for compilation and graph visualization.</p>
<p>  ragel -R simple.rl</p>
<p>  ragel -V simple.rl &gt; simple.dot</p>
<p>  dot -Tsvg simple.dot -o simple.svg</p>
<p>  dot -Tpng simple.dot -o simple.png</p>
</section>
<section id="slide-title" class="slide">
<p>Ruby projects using Ragel</p>
<ul>
<li>Mongrel, Unicorn, Puma</li>
<li>Whitequark</li>
<li>Mail</li>
<li>RedCloth</li>
<li>Hpricot</li>
</ul>
</section>
<section id="slide-title" class="slide">
<p>TODO: Examples in the Wild:
1) whitequark
2) <a href="https://github.com/github/linguist/tree/master/samples/Ragel%20in%20Ruby%20Host">https://github.com/github/linguist/tree/master/samples/Ragel%20in%20Ruby%20Host</a>
3) Gherkin: A fast lexer and parser for the Gherkin language based on Ragel. Gherkin is two things: <a href="https://github.com/cucumber/gherkin/blob/master/ragel/lexer.rb.rl.erb">https://github.com/cucumber/gherkin/blob/master/ragel/lexer.rb.rl.erb</a>
4) mongrel / ragel / puma
5) RedCloth (textile markup parser)</p>
</section>
<section id="slide-title" class="slide">
<p>SIMPLE REGEXP-LIKE MACHINES</p>
</section>
<section id="slide-title" class="slide">
<p>FULL-BLOWN CONTEXT-SENSITIVE SCANNERS</p>
</section>
<section id="slide-title" class="slide">
<p>PROTOCOL PARSING</p>
</section>
<section id="slide-title" class="slide">
<p>LANGUAGE GRAMMARS</p>
</section>
<section id="slide-title" class="slide">
<p>Talk to me, baby!</p>
<p>github.com/ijcd
@ijcd</p>
</section>
<section id="slide-title" class="slide">
<p>=begin
%%{
  machine simple_lexer;</p>
<p>  integer     = (&#39;+&#39;|&#39;-&#39;)?[0-9]+;
  float       = (&#39;+&#39;|&#39;-&#39;)?[0-9]+&#39;.&#39;[0-9]+;
  assignment  = &#39;=&#39;;
  identifier  = [a-zA-Z][a-zA-Z_]+;</p>
<p>  main := |*</p>
<pre><code><span class="hljs-title">integer</span> =&gt; {
  emit(:integer_literal, <span class="hljs-typedef"><span class="hljs-keyword">data</span>, token_array, ts, te)</span>
};

<span class="hljs-title">float</span> =&gt; {
  emit(:float_literal, <span class="hljs-typedef"><span class="hljs-keyword">data</span>, token_array, ts, te)</span>
};

<span class="hljs-title">assignment</span> =&gt; {
  emit(:assignment_operator, <span class="hljs-typedef"><span class="hljs-keyword">data</span>, token_array, ts, te)</span>
};

<span class="hljs-title">identifier</span> =&gt; {
  emit(:identifier, <span class="hljs-typedef"><span class="hljs-keyword">data</span>, token_array, ts, te)</span>
};

<span class="hljs-title">space</span>;
</code></pre><p>  *|;
}%%
=end</p>
<p>def emit(token_name, data, target_array, ts, te)
  target_array &lt;&lt; {:name =&gt; token_name.to_sym, :value =&gt; data[ts...te].pack(&quot;c*&quot;) }
end</p>
<p>def run_lexer(data)
  data = data.unpack(&quot;c*&quot;) if(data.is_a?(String))
  eof = data.length
  token_array = []</p>
<p>  %% write init;
  %% write exec;</p>
<p>  puts token_array.inspect
end</p>
</section>
<section id="slide-title" class="slide">
<p>Ragel code looks like:</p>
<p>action dgt      { printf(&quot;DGT: %c\n&quot;, fc); }
action dec      { printf(&quot;DEC: .\n&quot;); }
action exp      { printf(&quot;EXP: %c\n&quot;, fc); }
action exp_sign { printf(&quot;SGN: %c\n&quot;, fc); }
action number   { /<em>NUMBER</em>/ }</p>
<p>number = (
    [0-9]+ $dgt ( &#39;.&#39; @dec [0-9]+ $dgt )?
    ( [eE] ( [+-] $exp_sign )? [0-9]+ $exp )?
) %number;</p>
<p>main := ( number &#39;\n&#39; )*;</p>
</section>
<section id="slide-title" class="slide">
<p>TODO: color &quot;enhanced&quot; labels in blue</p>
</section>
<section id="hello" class="slide">
<h2>Hello</h2><p>Include images from &quot;images&quot; folder</p>
<p><img src="images/magic.gif" alt=""></p>
</section>
<section id="slide-title" class="slide">
<h2>Want to write HTML?</h2>

<p>yes, yes you can :)</p>

<p><img src="images/magic.gif"></p>
</section>
<section id="speaker-notes" class="slide" data-has-notes="true">
<h2>Speaker notes</h2><p>Hit <code>s</code> on your keyboard to display speaker notes</p><aside class="notes"><p>Here are the secret speaker notes!</p>
<p>Use <code>--such-notes</code> if they deserve better treatment.</p></aside>
</section>
<section id="slide-properties" class="slide" data-background="#FF69B4">
<h2>Slide properties</h2><p>Look at this shiny <code>hot-pink</code> background!</p>
<p>It has been added on this slide with this <code>$</code> syntax:</p>
<pre><code><span class="hljs-variable">$background</span>:<span class="hljs-hexcolor">#FF69B4</span>$
</code></pre>
</section>
<section id="goodbye" class="slide">
<h2>Goodbye</h2><p>Don&#39;t hesitate to give us feedback about <a href="https://github.com/lmtm/prez">prez on GitHub</a>!</p>
<p>Thanks</p>
</section>
<section id="slide-title" class="slide">
<p>PROTOCOL PARSING</p>
</section>
<section id="slide-title" class="slide">
<p>LANGUAGE GRAMMARS</p>
</section>
<section id="slide-title" class="slide">
<p>Talk to me, baby!</p>
<p>github.com/ijcd
@ijcd</p>
</section>
<section id="slide-title" class="slide">
<p>=begin
%%{
  machine simple_lexer;</p>
<p>  integer     = (&#39;+&#39;|&#39;-&#39;)?[0-9]+;
  float       = (&#39;+&#39;|&#39;-&#39;)?[0-9]+&#39;.&#39;[0-9]+;
  assignment  = &#39;=&#39;;
  identifier  = [a-zA-Z][a-zA-Z_]+;</p>
<p>  main := |*</p>
<pre><code><span class="hljs-title">integer</span> =&gt; {
  emit(:integer_literal, <span class="hljs-typedef"><span class="hljs-keyword">data</span>, token_array, ts, te)</span>
};

<span class="hljs-title">float</span> =&gt; {
  emit(:float_literal, <span class="hljs-typedef"><span class="hljs-keyword">data</span>, token_array, ts, te)</span>
};

<span class="hljs-title">assignment</span> =&gt; {
  emit(:assignment_operator, <span class="hljs-typedef"><span class="hljs-keyword">data</span>, token_array, ts, te)</span>
};

<span class="hljs-title">identifier</span> =&gt; {
  emit(:identifier, <span class="hljs-typedef"><span class="hljs-keyword">data</span>, token_array, ts, te)</span>
};

<span class="hljs-title">space</span>;
</code></pre><p>  *|;
}%%
=end</p>
<p>def emit(token_name, data, target_array, ts, te)
  target_array &lt;&lt; {:name =&gt; token_name.to_sym, :value =&gt; data[ts...te].pack(&quot;c*&quot;) }
end</p>
<p>def run_lexer(data)
  data = data.unpack(&quot;c*&quot;) if(data.is_a?(String))
  eof = data.length
  token_array = []</p>
<p>  %% write init;
  %% write exec;</p>
<p>  puts token_array.inspect
end</p>
</section>
<section id="slide-title" class="slide">
<p>Ragel code looks like:</p>
<p>action dgt      { printf(&quot;DGT: %c\n&quot;, fc); }
action dec      { printf(&quot;DEC: .\n&quot;); }
action exp      { printf(&quot;EXP: %c\n&quot;, fc); }
action exp_sign { printf(&quot;SGN: %c\n&quot;, fc); }
action number   { /<em>NUMBER</em>/ }</p>
<p>number = (
    [0-9]+ $dgt ( &#39;.&#39; @dec [0-9]+ $dgt )?
    ( [eE] ( [+-] $exp_sign )? [0-9]+ $exp )?
) %number;</p>
<p>main := ( number &#39;\n&#39; )*;</p>
</section>
<section id="slide-title" class="slide">
<p>TODO: color &quot;enhanced&quot; labels in blue</p>
</section>
<section id="hello" class="slide">
<h2>Hello</h2><p>Include images from &quot;images&quot; folder</p>
<p><img src="images/magic.gif" alt=""></p>
</section>
<section id="slide-title" class="slide">
<h2>Want to write HTML?</h2>

<p>yes, yes you can :)</p>

<p><img src="images/magic.gif"></p>
</section>
<section id="speaker-notes" class="slide" data-has-notes="true">
<h2>Speaker notes</h2><p>Hit <code>s</code> on your keyboard to display speaker notes</p><aside class="notes"><p>Here are the secret speaker notes!</p>
<p>Use <code>--such-notes</code> if they deserve better treatment.</p></aside>
</section>
<section id="slide-properties" class="slide" data-background="#FF69B4">
<h2>Slide properties</h2><p>Look at this shiny <code>hot-pink</code> background!</p>
<p>It has been added on this slide with this <code>$</code> syntax:</p>
<pre><code><span class="hljs-variable">$background</span>:<span class="hljs-hexcolor">#FF69B4</span>$
</code></pre>
</section>
<section id="goodbye" class="slide">
<h2>Goodbye</h2><p>Don&#39;t hesitate to give us feedback about <a href="https://github.com/lmtm/prez">prez on GitHub</a>!</p>
<p>Thanks</p>
</section>
<section>

</section></div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,

      transition: Reveal.getQueryHash().transition || 'slide', // none/fade/slide/convex/concave/zoom

      // Optional reveal.js plugins
      dependencies: [
        //{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        //{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        //{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: 'plugin/zoom-js/zoom.js', async: true },
        { src: 'plugin/notes/notes.js', async: true }
      ]
    });
    </script>

    <script src="js/dynamic-theme.js"></script><script src="js/such-notes-print.js"></script><script src="js/custom.js"></script>

  </body>
</html>
