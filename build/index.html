<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Prez</title>

    <meta name="description" content="-- DESCRIPTION HERE --">
    <meta name="author" content="ijcd">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/solarized.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="css/highlight/styles/zenburn.css" id="highlight-theme">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <link rel="stylesheet" href="css/custom.css">

  </head>

  <body>

    <div class="reveal">
      <div class="slides"><section id="stately-state-machines-with-ragel" class="slide" data-has-notes="true">
<h2>Stately State Machines With Ragel</h2><p><img src="images/babbage.jpg" alt=""></p>
<p>RubyConf 2015</p>
<p>Ian Duggan</p><aside class="notes"><p>Joke: Statistician and Mathematician — please analyze this number — it’s two. Statistician: somewhere between 1.99999999 and 2.00000001 but we can’t be sure. Engineer: 2? It’s 2? Ok, well, we should make it 3. No, you know what? Let’s make it 4 just to be safe.</p></aside>
</section>
<section id="goals-for-this-talk" class="slide">
<p><br></p>
<h2>Goals for This Talk</h2><ol>
<li><p>Convince you that Ragel is worth trying.</p>
</li>
<li><p>Give you some intuition about how it works.</p>
</li>
<li><p>Show you how to setup a basic parser.</p>
</li>
</ol>
</section>
<section id="hello" class="slide">
<h2>Hello</h2><p>My name is Ian Duggan</p>
<p><img src="images/ian_carrot.jpg" alt=""></p>
</section>
<section id="i-play-hockey" class="slide" data-has-notes="true">
<h2>I Play Hockey</h2><p>Several times a week.</p>
<p><img src="images/stormy_the_pig.jpg" alt=""></p><aside class="notes"><p>This is Stormy the pig. In North Carolina, where I&#39;m from, pigs apparently mean hockey.</p></aside>
</section>
<section id="i-play-guitar" class="slide" data-has-notes="true">
<h2>I Play Guitar</h2><p>And banjo. And mandolin. And ukulele. Poorly. I have a fiddle that&#39;s gathering dust.</p>
<p><img src="images/musical_instruments.jpg" alt=""></p><aside class="notes"><p>My cats are happy that it&#39;s gathering dust.</p></aside>
</section>
<section id="sometimes-i-fly" class="slide" data-has-notes="true">
<h2>Sometimes I Fly</h2><p><img src="images/cessna120.jpg" alt=""></p><aside class="notes"><p>This is my little Cessna 120 that I fly out of Hayward, CA. It has a whopping 85 horses, but it&#39;s fun to putt-putt around the bay and valley in.</p></aside>
</section>
<section id="i-love-my-cats" class="slide" data-has-notes="true">
<h2>I Love My Cats</h2><p><img src="images/boofus_cozy1.jpg" alt=""></p><aside class="notes"><p>This is Purrington. Most of the time we call him Boofus. It just seems more fitting.</p></aside>
</section>
<section id="they-are-goofballs" class="slide" data-has-notes="true">
<h2>They Are Goofballs</h2><p><img src="images/minnie_antlers.jpg" alt=""></p><aside class="notes"><p>This is Meowington. She usally goes by &quot;Minnie&quot; or &quot;Minnie-Moo&quot;. She&#39;ll sit for hours in these outfits. She doesn&#39;t care. She likes the attention. She also moos at us a lot. She&#39;s quite talkative.</p></aside>
</section>
<section id="but-very-furry" class="slide" data-has-notes="true">
<h2>But Very Furry</h2><p><img src="images/boofus_cozy2.jpg" alt=""></p><aside class="notes"><p>Boofus likes being cozy.</p></aside>
</section>
<section id="and-dopey" class="slide" data-has-notes="true">
<h2>And Dopey</h2><p><img src="images/minnie_hoodie.jpg" alt=""></p><aside class="notes"><p>slide 10
3 minutes</p></aside>
</section>
<section id="and-relaxed" class="slide" data-has-notes="true">
<h2>And Relaxed</h2><p><img src="images/boofus_relaxed.jpg" alt=""></p><aside class="notes"><p>Boofus is more chill.</p></aside>
</section>
<section id="and-fun" class="slide" data-has-notes="true">
<h2>And Fun</h2><p><img src="images/minnie_bucket.jpg" alt=""></p><aside class="notes"><p>Minnie likes to sit in strange places.</p></aside>
</section>
<section id="software-ftw" class="slide">
<h2>Software! FTW!</h2><p>I&#39;m a software dude. I code things. I code the internets and the
googles. I&#39;m also a recovering technology entrepreneur. I&#39;ve been in
and out of startup institutions my entire life.</p>
<p><img src="images/software_eng.jpg" alt=""></p>
</section>
<section id="current-status" class="slide">
<h2>Current Status</h2><p><img src="images/twitch.jpg" alt=""></p>
</section>
<section id="were-hiring-of-course" class="slide">
<h2>We&#39;re Hiring (of course)</h2><p>Lots of Ruby.</p>
<p><img src="images/ruby.png" alt=""></p>
</section>
<section id="were-hiring-of-course" class="slide">
<h2>We&#39;re Hiring (of course)</h2><p>Lots of Go.</p>
<p><img src="images/gopher.jpg" alt=""></p>
</section>
<section id="im-a-rubyist-since-" class="slide" data-has-notes="true">
<h2>I&#39;m a Rubyist, since 1.6</h2><p>I&#39;ve been using Ruby casually since the 1.6 days, and professionally
for more than a decade.</p>
<p><img src="images/ruby_16.jpg" alt=""></p><aside class="notes"><p>I forget when the transition exactly happened,
but one day I just found myself using Ruby for everything. It&#39;s a very
nice language.</p></aside>
</section>
<section id="today-is-about-ragel" class="slide" data-has-notes="true">
<p><br></p>
<h2>Today is About Ragel</h2><p><img src="images/ragel.png" alt=""></p><aside class="notes"><p>However, today I&#39;m here to talk to you today about another incredible
tool, Ragel.</p>
<p>It&#39;s amazing. It can do almost anything.</p>
<p>Well, almost anything.</p>
<p>Actually, nearly anything related to parsing text.</p>
<p>You can get a few more tricks out of it but that&#39;s the main use case.</p></aside>
</section>
<section id="ragel-is-really-cool" class="slide" data-has-notes="true">
<h2>Ragel Is Really Cool</h2><p>If you don&#39;t have it in your bat-belt yet, you need to add it. Today!</p>
<p><img src="images/adam_west_batman.jpg" alt=""></p><aside class="notes"><p>Ragel excels at ripping-fast parsing and processing of textual data.</p></aside>
</section>
<section id="ruby-projects-using-ragel" class="slide" data-has-notes="true">
<p><br></p>
<h2>Ruby projects using Ragel</h2><ul>
<li>Mongrel, Unicorn, Puma</li>
<li>Whitequark</li>
<li>Mail</li>
<li>RedCloth</li>
<li>Hpricot</li>
<li>Gherkin</li>
</ul>
<p><a href="https://github.com/whitequark/parser/blob/master/lib/parser/lexer.rl">https://github.com/whitequark/parser/blob/master/lib/parser/lexer.rl</a></p><aside class="notes"><p>If you need more examples after this talk, these are good projects to look at.</p>
<p>Note:
slide 20
6 minutes</p></aside>
</section>
<section id="what-does-ragel-look-like" class="slide">
<p><br></p>
<h2>What Does Ragel Look Like?</h2><pre><code>%%{
action dgt      { printf(<span class="hljs-string">"DGT: %c\n"</span>, fc); }
action dec      { printf(<span class="hljs-string">"DEC: .\n"</span>); }
action exp      { printf(<span class="hljs-string">"EXP: %c\n"</span>, fc); }
action exp_sign { printf(<span class="hljs-string">"SGN: %c\n"</span>, fc); }
action number   { /*NUMBER*/ }

number = (
    [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+ <span class="hljs-variable">$dgt</span> ( <span class="hljs-string">'.'</span> @dec [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+ <span class="hljs-variable">$dgt</span> )?
    ( [eE] ( [+\-] <span class="hljs-variable">$exp</span>_sign )? [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+ <span class="hljs-variable">$exp</span> )?
) <span class="hljs-decorator">%number</span>;

main := ( number <span class="hljs-string">'\n'</span> )*;
}%%
</code></pre>
</section>
<section id="but-regular-expressions-are-easy" class="slide" data-has-notes="true">
<h2>But Regular Expressions are easy!</h2><p>Regular expressions consist of constants and operator symbols that denote sets of strings and operations over these sets, respectively. (from Wikipedia)</p>
<pre><code>   /a/         # <span class="hljs-keyword">match</span> a
   /abc/       # <span class="hljs-keyword">match</span> <span class="hljs-string">"a"</span>, <span class="hljs-keyword">then</span> <span class="hljs-string">"b"</span>, <span class="hljs-keyword">then</span> <span class="hljs-string">"c"</span> (concatenation)
   /a|b/       # <span class="hljs-keyword">match</span> <span class="hljs-string">"a"</span> <span class="hljs-keyword">or</span> <span class="hljs-string">"b"</span> (alteration)
   /gr(a|e)y/  # <span class="hljs-keyword">match</span> <span class="hljs-string">"gr"</span>, <span class="hljs-keyword">then</span> <span class="hljs-string">"a"</span> <span class="hljs-keyword">or</span> <span class="hljs-string">"e"</span>, <span class="hljs-keyword">then</span> <span class="hljs-string">"y"</span> (grouping)
   /a?/        # <span class="hljs-keyword">match</span> zero <span class="hljs-keyword">or</span> one <span class="hljs-string">"a"</span>
   /a*/        # <span class="hljs-keyword">match</span> zero <span class="hljs-keyword">or</span> more <span class="hljs-string">"a"</span>
   /a+/        # <span class="hljs-keyword">match</span> one <span class="hljs-keyword">or</span> more <span class="hljs-string">"a"</span>
   /a{<span class="hljs-number">18</span>}/     # <span class="hljs-keyword">match</span> <span class="hljs-string">"a"</span> <span class="hljs-number">18</span> times
   /a{<span class="hljs-number">2</span>,}/     # <span class="hljs-keyword">match</span> <span class="hljs-string">"a"</span> <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> more times
   /a{<span class="hljs-number">2</span>,<span class="hljs-number">10</span>}/   # <span class="hljs-keyword">match</span> <span class="hljs-string">"a"</span> between <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> <span class="hljs-number">10</span> more times
</code></pre><aside class="notes"><p>Most people should be familiar with the standard regexp form.</p></aside>
</section>
<section id="ruby-has-great-tools-for-regular-expressions" class="slide">
<h2>Ruby has great tools for regular expressions</h2><p>You can get by with them. You can especially get by with them in Ruby which draws its heritage from Perl, Sed, and Awk which made wonderful use of regexps.</p>
<pre><code>@dot = @dot.gsub(/^.*-&gt;.*$/) <span class="hljs-built_in">do</span> |<span class="hljs-built_in">line</span>|
  <span class="hljs-built_in">line</span>.gsub(/label = <span class="hljs-string">".*"</span>/) <span class="hljs-built_in">do</span> |labels|
    labels.gsub(/\b\d+/) { |<span class="hljs-built_in">num</span>| ASCII_MAP[<span class="hljs-built_in">num</span>] || <span class="hljs-built_in">num</span> }
  <span class="hljs-function"><span class="hljs-keyword">end</span>
<span class="hljs-title">end</span></span>
</code></pre>
</section>
<section id="irregular-expressions" class="slide" data-has-notes="true">
<h2>Irregular Expressions</h2><p>zarro boogs found</p>
<p><img src="images/regular_expression.jpg" alt=""></p><aside class="notes"><p>What&#39;s that you say? Parsing text?</p>
<p>Parsing text is easy.</p>
<p>You just use regular expressions, right?</p>
<p>Simple. No problem.</p>
<p>They have their place, but you can reach for something better.</p></aside>
</section>
<section id="sometimes-you-want-more-control" class="slide" data-has-notes="true">
<h2>Sometimes You Want More Control</h2><p>I posit that this might be some sort of automaton.</p>
<p><img src="images/automaton.jpg" alt=""></p><aside class="notes"><p>Regepx work fine. Why do we need something better?</p></aside>
</section>
<section id="finite-automata" class="slide" data-has-notes="true">
<p><br></p>
<h2>Finite Automata</h2><ul>
<li><p>Have states and transitions.</p>
</li>
<li><p>Change state based on sequence of inputs.</p>
</li>
<li><p><strong>DFA</strong> can be in only one state at a time.</p>
</li>
<li><p><strong>NFA</strong> can be in more than one state at a time.</p>
</li>
</ul><aside class="notes"><p>But, we can convert an NFA into a DFA by making &quot;super states&quot; from these dual states. This grows combinatorically, of course.</p></aside>
</section>
<section id="equivalence-of-regular-expressions-nfas-and-dfas" class="slide">
<h2>Equivalence of Regular Expressions, NFAs, and DFAs</h2><blockquote>
<p>It is possible to convert freely between regular expressions,
deterministic finite automata, and nondeterministic finite
automata. Given one, we can convert it to any of the other forms.</p>
</blockquote>
<p><a href="http://faculty.ycp.edu/~dhovemey/fall2008/cs340/notes/lecture3.html">http://faculty.ycp.edu/~dhovemey/fall2008/cs340/notes/lecture3.html</a></p>
</section>
<section id="these-are-all-state-machines" class="slide">
<p><br></p>
<h2>These Are All State Machines</h2><p><br></p>
<p>State machines are an important tool in computer programming, and Ragel is a wonderful tool for creating them.</p>
</section>
<section id="state-machines-are-everywhere" class="slide">
<h2>State machines are everywhere</h2><p><img src="images/state_machines_everywhere.png" alt=""></p>
</section>
<section id="theyre-in-your-stoplight" class="slide" data-has-notes="true">
<p><br></p>
<h2>They&#39;re in your stoplight</h2><p><br>
<img src="images/stoplight.gif" alt=""></p><aside class="notes"><p>slide 30
9 minutes</p></aside>
</section>
<section id="they-run-your-cpu" class="slide" data-has-notes="true">
<h2>They run your CPU</h2><p><img src="images/cpu_machine.png" alt=""></p><aside class="notes"><p>Every tick of your CPU advancing a state machine from one state to
another...</p>
<p>Take all of the bits in your computer and label each combination as a state.</p>
<p>Take all of the input bits and label those as different inputs.</p>
<p>That&#39;s a big horkin&#39; state machine.</p></aside>
</section>
<section id="there-are-examples-everywhere" class="slide">
<p><br></p>
<h2>There are examples everywhere</h2><ul>
<li>watch with timer</li>
<li>vending machine</li>
<li>traffic light</li>
<li>bar code scanner</li>
<li>gas pumps</li>
<li>number classification</li>
</ul>
</section>
<section id="the-cats-meow" class="slide">
<p><br></p>
<h1>The Cat&#39;s Meow?</h1><p>State machines are great for many reasons. They are simple to understand, and there has been a great deal of research around finite automata and state machines. With the right approach they can also produce code that is faster, easier to maintain, and more correct and thus more secure.</p>
</section>
<section id="still-not-convinced" class="slide">
<p><br><br></p>
<h1>Still Not Convinced?</h1><p>Rather than me trying to convince you that they&#39;re useful, let&#39;s just talk about them for a bit and see where we end up.</p>
</section>
<section id="lets-go-over-some-vocabulary" class="slide">
<p><br><br></p>
<h1>Let&#39;s go over some vocabulary</h1>
</section>
<section id="start-state" class="slide">
<p><br></p>
<h1>Start state</h1><p>This is the initial state of a machine.</p>
<p>(S0)</p>
</section>
<section id="accept-state" class="slide">
<h1>Accept state</h1><p>In this state, the machine is said to have &quot;accepted&quot; the input.</p>
<p>(double circle)</p>
<p><img src="images/accept_state.png" alt=""></p>
</section>
<section id="transition" class="slide">
<h1>Transition</h1><p>Upon consuming a single character, the machine can move from one state to another.</p>
<p>(labelled arrow)</p>
<p><img src="images/transition_arrow.png" alt=""></p>
</section>
<section id="epsilon-transition" class="slide" data-has-notes="true">
<h1>Epsilon Transition</h1><p>Allows an automaton to change its state spontaneously, i.e. without
consuming an input symbol.</p>
<p><img src="images/epsilon_transition.png" alt=""></p><aside class="notes"><p>These can be used to wire machines together.</p>
<p>Composition.</p>
<p>Computer science.</p></aside>
</section>
<section id="simple-machines" class="slide" data-has-notes="true">
<h1>Simple Machines</h1><p>  &#39;a&#39;, &#39;a&#39;*, &#39;a&#39;+</p>
<p><img src="images/simple_machines.png" alt=""></p><aside class="notes"><p>slide 40
12 minutes</p></aside>
</section>
<section id="more-complex" class="slide">
<h1>More Complex</h1><p>&#39;hello&#39;*</p>
<p>Zero or more hellos.</p>
<p><img src="images/hello_star.png" alt=""></p>
</section>
<section id="whats-the-big-deal" class="slide" data-has-notes="true">
<p><br><br><br></p>
<h1>What&#39;s the Big Deal?</h1><p>These just look like regular expressions.</p><aside class="notes"><p>They are, more or less.</p>
<p>However, Ragel has a few more tricks up it&#39;s sleeve.</p>
<p>We&#39;re going to compose these simple machines.</p>
<p>And execute arbitrary actions at any point inside them.</p>
<p>That is when things get really cool.</p></aside>
</section>
<section id="what-is-ragel-exactly" class="slide">
<h2>What is Ragel Exactly?</h2><blockquote>
<p>Ragel is a finite-state machine compiler with output support for C,
C++, C#, Objective-C, D, Java, OCaml, Go, and Ruby source code.
It supports the generation of table or control flow driven state
machines from regular expressions and/or state charts and can
also build lexical analysers via the longest-match method. Ragel
specifically targets text parsing and input validation.</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Ragel">https://en.wikipedia.org/wiki/Ragel</a></p>
</section>
<section id="state-machine-generation" class="slide">
<h2>State Machine Generation</h2><blockquote>
<p>Ragel supports the generation of table or control flow driven state
machines from regular expressions and/or state charts and can also
build lexical analysers via the longest-match method. A unique feature
of Ragel is that user actions can be associated with arbitrary state
machine transitions using operators that are integrated into the
regular expressions. Ragel also supports visualization of the
generated machine via graphviz.</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Ragel">https://en.wikipedia.org/wiki/Ragel</a></p>
</section>
<section id="how-do-you-pronounce-it" class="slide" data-has-notes="true">
<p><br></p>
<h2>How Do You Pronounce It?</h2><ul>
<li>RAY-gull?</li>
<li>RAY-jul?</li>
<li>RAH-gull?</li>
<li>RAH-jul?</li>
</ul><aside class="notes"><p>(pro-nouns-key-ay-shun)</p></aside>
</section>
<section id="lets-get-it-from-the-horses-mouth" class="slide">
<p><br></p>
<h2>Let&#39;s get it from the horse&#39;s mouth</h2><p><img src="images/horses_mouth.jpg" alt=""></p>
</section>
<section id="adrian-d-thurston-created-ragel" class="slide">
<h2>Adrian D. Thurston Created Ragel</h2><p><a href="https://www.mail-archive.com/ragel-users@complang.org/msg00344.html">https://www.mail-archive.com/ragel-users@complang.org/msg00344.html</a></p>
<pre><code>Re: [ragel-users] pronounciation
Adrian Thurston Sat, <span class="hljs-number">10</span> Apr <span class="hljs-number">2010</span> <span class="hljs-number">09</span>:<span class="hljs-number">02</span>:<span class="hljs-number">10</span> -<span class="hljs-number">0700</span>

Hi Landon,

I usually <span class="hljs-command">say</span> something like <span class="hljs-string">"rah-ghel."</span> I had no
phonetic basis <span class="hljs-keyword">for</span> <span class="hljs-keyword">it</span> when I picked <span class="hljs-keyword">it</span>. I just took <span class="hljs-keyword">my</span> nickname
<span class="hljs-string">"Age"</span> <span class="hljs-keyword">and</span> wrapped <span class="hljs-keyword">it</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> R <span class="hljs-keyword">and</span> L <span class="hljs-keyword">of</span> regular languages. I've
<span class="hljs-keyword">since</span> learned <span class="hljs-keyword">that</span> <span class="hljs-keyword">it</span> means <span class="hljs-string">"man"</span> <span class="hljs-keyword">in</span> Arabic.

Adrian

Landon Cox wrote:
&gt; Hi Adrian <span class="hljs-keyword">and</span> others,
&gt;
&gt; Simple question:  What <span class="hljs-keyword">is</span> <span class="hljs-keyword">the</span> pronunciation <span class="hljs-keyword">of</span> <span class="hljs-string">"Ragel"</span>?
&gt; 
&gt; Is <span class="hljs-keyword">it</span> <span class="hljs-string">"Ray-Gull"</span> <span class="hljs-keyword">or</span> <span class="hljs-string">"Rag-El"</span> (like dish rag) <span class="hljs-keyword">or</span> <span class="hljs-string">"Rage-El"</span> ?
&gt;
&gt; Thanks,
&gt; 
&gt; Landon
</code></pre>
</section>
<section id="well-darn-ive-been-pronouncing-it-wrong-for-quite-some-time" class="slide" data-has-notes="true">
<p><br></p>
<h1>Well, darn. I&#39;ve been pronouncing it wrong for quite some time!</h1><aside class="notes"><p>For too long, actually. I&#39;m not sure if I&#39;ll be able to change. I will if you do.</p></aside>
</section>
<section id="ragel-is-a-dsl-for-creating-state-machines" class="slide" data-has-notes="true">
<p><br></p>
<h2>Ragel is a DSL for creating state machines</h2><p>It is espcially useful for parsing protocols and data formats. (HTTP, XML, JSON, CSS, etc...)</p><aside class="notes"><p>From a high-level, it helps you build regular expressions, but with an important difference.</p>
<p>With Ragel, you have the ability to stop at any point in the regexp parse and execute code in the host language.</p>
<p>This is incredibly powerful.</p>
<p>It means that rather than having a large program with lots of regexps, loops, and conditionals, we can have one
EBNF-ish looking definition that, instead, calls out to our code when we need it to.</p>
<p>You can do some really cool tricks with this.</p></aside>
</section>
<section id="lets-look-at-the-dsl" class="slide">
<p><br><br><br></p>
<h1>Let&#39;s look at the DSL</h1>
</section>
<section id="general-structure-of-a-ragel-file" class="slide">
<p><br></p>
<h2>General Structure of a Ragel File</h2><ul>
<li>Mostly in the host language</li>
<li>has a .rl extension (simple.rl)</li>
<li>%% is used for inline statements</li>
<li>%%{ is used for multiline statements }%%</li>
</ul>
<pre><code><span class="hljs-variable">%%</span>{
  machine foobar;
  main := <span class="hljs-string">'foobar'</span>;
}<span class="hljs-variable">%%</span>

<span class="hljs-variable">%%</span>write init;
<span class="hljs-variable">%%</span>write <span class="hljs-keyword">exec</span>;
</code></pre>
</section>
<section id="naming-a-machine" class="slide">
<h2>Naming a Machine</h2><p>With named machines, you can spread a machine&#39;s statements across several files or include common sections.</p>
<pre><code>    machine phone_parser<span class="hljs-comment">;</span>
</code></pre>
</section>
<section id="machine-definition" class="slide" data-has-notes="true">
<h2>Machine Definition</h2><p>You define a machine using the equals operator.</p>
<pre><code>    <span class="hljs-tag">&lt;<span class="hljs-title">name</span>&gt;</span> = <span class="hljs-tag">&lt;<span class="hljs-title">expression</span>&gt;</span>;
</code></pre><p>This allows it to be referenced later.</p><aside class="notes"><p>The machine definition statement associates an FSM expression with a name.</p>
<p>Machine expressions assigned to names can later be referenced in other expressions.</p>
<p>A definition statement on its own does not cause any states to be generated.</p>
<p>It is simply a description of a machine to be used later.</p>
<p>States are generated only when a definition is instantiated, which happens when a definition is referenced in an instantiated expression.</p></aside>
</section>
<section id="machine-instantiation" class="slide" data-has-notes="true">
<h2>Machine Instantiation</h2><p>This causes the actual generation of the referenced set of states.</p>
<pre><code>  <span class="hljs-tag">&lt;<span class="hljs-title">name</span>&gt;</span> := <span class="hljs-tag">&lt;<span class="hljs-title">expression</span>&gt;</span>;
</code></pre><p>Each instantiation generates a distinct set of states.</p><aside class="notes"><p>Starting state written to the data section.</p>
<p>If main used, it is set as the start state.</p>
<p>If not, the last machine instantiated has the start state.</p></aside>
</section>
<section id="file-inclusion-and-import" class="slide">
<h2>File Inclusion and Import</h2><p>You can include and import definitions from other files.</p>
<pre><code>    <span class="hljs-preprocessor"><span class="hljs-keyword">include</span> FsmName "inputfile.rl";</span>

    <span class="hljs-preprocessor"><span class="hljs-keyword">import</span> "inputfile.h";</span>
</code></pre><p>These can help you keep things organized. See the manual for the specific semantics of each.</p>
</section>
<section id="whitespace" class="slide">
<p><br></p>
<h1>Whitespace</h1><p>  Any amount of whitespace can separate tokens.</p>
</section>
<section id="comments" class="slide">
<h1>Comments</h1><pre><code>  # <span class="hljs-keyword">is</span> used <span class="hljs-keyword">for</span> single <span class="hljs-built_in">line</span> comments
</code></pre>
</section>
<section id="literals" class="slide">
<h1>Literals</h1><p>Literals are contained in quotes, regexp slashes, or brackets for groupings.</p>
<pre><code>  <span class="hljs-string">""</span>    <span class="hljs-preprocessor"># string</span>
  <span class="hljs-string">''</span>    <span class="hljs-preprocessor"># string</span>
  //    <span class="hljs-preprocessor"># regexp</span>
  []    <span class="hljs-preprocessor"># union</span>
</code></pre>
</section>
<section id="escape-characters" class="slide">
<h1>Escape Characters</h1><pre><code>  <span class="hljs-string">\0</span>    <span class="hljs-literal">null</span>
  <span class="hljs-string">\a</span>    
  <span class="hljs-string">\b</span>    backspace
  <span class="hljs-string">\t</span>    tab
  <span class="hljs-string">\n</span>    newline
  <span class="hljs-string">\v</span>    vtab
  <span class="hljs-string">\f</span>    formfeed
  <span class="hljs-string">\r</span>    carriage <span class="hljs-keyword">return</span>
</code></pre><p>You can escape the end of a line with a \ (as in shell scripting)</p>
</section>
<section id="host-language-code" class="slide">
<h1>Host Language Code</h1><p>Braces are used to delimit host language code</p>
<pre><code><span class="hljs-preprocessor">%</span><span class="hljs-preprocessor">%</span>{
   { puts <span class="hljs-string">"I am ruby"</span> }    
}<span class="hljs-preprocessor">%</span><span class="hljs-preprocessor">%</span>
</code></pre>
</section>
<section id="numbers" class="slide">
<h1>Numbers</h1><p>Integers and hexadecimals can be used to refer to numbers.</p>
<pre><code>    [+-]?[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+            <span class="hljs-preprocessor"># integers    (-<span class="hljs-number">23432</span>, +<span class="hljs-number">23423</span>, <span class="hljs-number">23423</span>)</span>
    <span class="hljs-number">0</span>x[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>A-fa-f]          <span class="hljs-preprocessor"># hexadecimal (<span class="hljs-number">0xABD</span>)</span>
</code></pre>
</section>
<section id="keywords" class="slide">
<h1>Keywords</h1><pre><code>    <span class="hljs-keyword">access</span>
    <span class="hljs-keyword">action</span>
    alphtype
    getkey
    <span class="hljs-built_in">write</span>
    machine
    <span class="hljs-keyword">include</span>
</code></pre>
</section>
<section id="concatenation-literal" class="slide">
<h1>Concatenation Literal</h1><p>Match on a sequence of letters.</p>
<pre><code><span class="hljs-comment">%%{</span>
  <span class="hljs-function_or_atom">machine</span> <span class="hljs-function_or_atom">simple</span>;
  <span class="hljs-function_or_atom">main</span> := <span class="hljs-string">'simple'</span>;
}<span class="hljs-comment">%%</span>
</code></pre><p><img src="images/simple_concat.png" alt=""></p>
</section>
<section id="union-expression" class="slide">
<h1>Union Expression</h1><pre><code><span class="hljs-comment">%%{</span>
  <span class="hljs-atom">machine</span> <span class="hljs-atom">union_range</span>;
  <span class="hljs-atom">union</span> := [<span class="hljs-atom">abc</span>];
  <span class="hljs-atom">union_range</span> := [<span class="hljs-atom">acm</span>-<span class="hljs-atom">z</span>];
}<span class="hljs-comment">%%</span>
</code></pre><p><img src="images/union_range.png" alt=""></p>
</section>
<section id="zero-length-machines" class="slide">
<h1>Zero Length Machines</h1><pre><code>%%{
  machine zero_length_machines;
  single <span class="hljs-value">:= <span class="hljs-string">''</span>;</span>
  <span class="hljs-value">double</span> <span class="hljs-value">:= <span class="hljs-string">""</span>;</span>
  bracket <span class="hljs-value">:= [];</span>
}%%
</code></pre><p><img src="images/zero_length_machine2.png" alt=""></p>
</section>
<section id="numerical-literal" class="slide">
<h1>Numerical Literal</h1><p>Produces a two-state machine with one transition on the given value, which can be given in decimal or hexadecimal.</p>
<pre><code><span class="hljs-var_expand">%%</span>{
  machine numerical_literal<span class="hljs-comment">;</span>
  main := <span class="hljs-number">42</span><span class="hljs-comment">;</span>
}<span class="hljs-var_expand">%%</span>
</code></pre><p><img src="images/numeric_literal.png" alt=""></p>
</section>
<section id="regular-expression" class="slide" data-has-notes="true">
<h1>Regular Expression</h1><pre><code><span class="hljs-comment">%%{</span>
  <span class="hljs-atom">machine</span> <span class="hljs-atom">regexp2</span>;
  <span class="hljs-atom">main</span> := /<span class="hljs-atom">ab</span>*[<span class="hljs-atom">c</span>-<span class="hljs-atom">z</span>].*[<span class="hljs-number">123</span>]/;
}<span class="hljs-comment">%%</span>
</code></pre><p><img src="images/regular_expression.png" alt=""></p><aside class="notes"><p>You don&#39;t need fancy regexps because the great Ragel engine allows you to do whatever you would need here.</p>
<p>How many turtles do you need?</p></aside>
</section>
<section id="range-expression" class="slide">
<h1>Range Expression</h1><p>Matches any character between &#39;a&#39; and &#39;z&#39; inclusive.</p>
<pre><code><span class="hljs-comment">%%{</span>
  <span class="hljs-function_or_atom">machine</span> <span class="hljs-function_or_atom">range</span>;
  <span class="hljs-function_or_atom">main</span> := <span class="hljs-string">'a'</span>..<span class="hljs-string">'z'</span>;
}<span class="hljs-comment">%%</span>
</code></pre><p><img src="images/range_expression.png" alt=""></p>
</section>
<section id="variable-name" class="slide">
<h1>Variable Name</h1><p>Inserts the machine referenced by this name.</p>
<pre><code>%%{
  machine variable_name;
  secret_code = [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]{<span class="hljs-number">2</span>};
  main := secret_code;
}%%
</code></pre><p><img src="images/variable_name.png" alt=""></p>
</section>
<section id="builtin-machines" class="slide">
<h2>Builtin Machines</h2><pre><code>    <span class="hljs-keyword">any</span>    – Any <span class="hljs-keyword">character</span> <span class="hljs-operator">in</span> <span class="hljs-operator">the</span> alphabet.
    ascii  – Ascii <span class="hljs-keyword">characters</span>. <span class="hljs-number">0.</span><span class="hljs-number">.127</span>
    extend – Ascii extended <span class="hljs-keyword">characters</span>. 
    alpha  – Alphabetic <span class="hljs-keyword">characters</span>. [A-Za-z]
    digit  - Digits. [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]
    alnum  – Alpha numerics. [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>A-Za-z]
    <span class="hljs-built_in">lower</span>  – Lowercase <span class="hljs-keyword">characters</span>. [<span class="hljs-operator">a</span>-z]
    <span class="hljs-built_in">upper</span>  – Uppercase <span class="hljs-keyword">characters</span>. [A-Z]
    xdigit - Hexadecimal digits. [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>A-Fa-f]
    cntrl  – Control <span class="hljs-keyword">characters</span>. <span class="hljs-number">0.</span><span class="hljs-number">.31</span>
    graph  – Graphical <span class="hljs-keyword">characters</span>. [!-~]
    print  – Printable <span class="hljs-keyword">characters</span>. [ -~]
    punct  – Punctuation. 
    <span class="hljs-constant">space</span>  - Whitespace. [\t\v\f\n\r ]
    zlen   - Zero <span class="hljs-built_in">length</span> <span class="hljs-keyword">string</span>. <span class="hljs-string">""</span>
    <span class="hljs-constant">empty</span>  - Empty <span class="hljs-built_in">set</span>. Matches nothing. ^<span class="hljs-keyword">any</span>
</code></pre>
</section>
<section id="building-blocks" class="slide">
<h1>Building Blocks</h1><p>We have simple machines now.</p>
<p>Like levers, wedges, wheels, and pulleys.</p>
<p>But let&#39;s not stop here.</p>
<p>From simple machines we can make complex machines.</p>
</section>
<section id="simple" class="slide">
<h2>Simple</h2><p><img src="images/simple_machines.jpg" alt=""></p>
</section>
<section id="complex" class="slide">
<h2>Complex</h2><p><img src="images/apollo.gif" alt=""></p>
</section>
<section id="isnt-she-cute" class="slide">
<h2>Isn&#39;t She Cute?</h2><p><img src="images/minnie_platform.jpg" alt=""></p>
</section>
<section id="composition" class="slide" data-has-notes="true">
<h1>Composition</h1><p>Ragel&#39;s DSL allows you to take these simple machines, and through some basic operators, combine those into bigger machines, and then combine those into BIGGER machines.</p><aside class="notes"><p>This is the part of Ragel that I found fascinating when I first grokked it.</p>
<p>This compositional technique is what gives Ragel it&#39;s extreme simplicity and combinational power.</p>
<p>I can&#39;t stress this point enough.</p></aside>
</section>
<section id="compositional-operators" class="slide">
<h2>Compositional Operators</h2><pre><code>    <span class="hljs-type">expr</span> | <span class="hljs-type">expr</span>   - union
    <span class="hljs-type">expr</span> &amp; <span class="hljs-type">expr</span>   - intersection
    <span class="hljs-type">expr</span> - <span class="hljs-type">expr</span>   - difference
    <span class="hljs-type">expr</span> -- <span class="hljs-type">expr</span>  - strong difference
    <span class="hljs-type">expr</span> . <span class="hljs-type">expr</span>   - concatenation
    <span class="hljs-type">expr</span>*         - kleene star
    <span class="hljs-type">expr</span>+         - one <span class="hljs-keyword">or</span> more repetion
    <span class="hljs-type">expr</span>?         - optional
    <span class="hljs-type">expr</span>{n}       - exactly N copies <span class="hljs-keyword">of</span> <span class="hljs-type">expr</span>
    <span class="hljs-type">expr</span>{n,}      - <span class="hljs-type">Zero</span> to N copies <span class="hljs-keyword">of</span> <span class="hljs-type">expr</span>
    <span class="hljs-type">expr</span>{,m}      - N <span class="hljs-keyword">or</span> more copies <span class="hljs-keyword">of</span> <span class="hljs-type">expr</span>
    <span class="hljs-type">expr</span>{n,m}     - N to M copies <span class="hljs-keyword">of</span> <span class="hljs-type">expr</span>  
    !<span class="hljs-type">expr</span>         - negation
    ^<span class="hljs-type">expr</span>         - character-level negation
</code></pre>
</section>
<section id="union" class="slide" data-has-notes="true">
<h1>Union</h1><p>Matches any string in machine one or machine two</p>
<pre><code><span class="hljs-type">expr</span> | <span class="hljs-type">expr</span>
</code></pre><p><img src="images/union.png" alt=""></p><aside class="notes"><p>The operation first creates a new start state.</p>
<p>Epsilon transitions are drawn from the new start state to the start states of both input
machines.</p>
<p>Nondeterminism. If there are strings, or prefixes of strings that are
matched by both machines then the new machine will follow both parts
of the alternation at once. The union operation is shown below.</p></aside>
</section>
<section id="union-example" class="slide">
<h1>Union Example</h1><pre><code><span class="hljs-var_expand">%%</span>{
  machine union2<span class="hljs-comment">;</span>
  # Hex digits, decimal digits, <span class="hljs-literal">or</span> identifiers
  main := digit+ | alpha alnum*<span class="hljs-comment">;</span>
}<span class="hljs-var_expand">%%</span>
</code></pre><p><img src="images/union_example.png" alt=""></p>
</section>
<section id="intersection" class="slide" data-has-notes="true">
<h1>Intersection</h1><p>Matches any string that is in both machine one and two.</p>
<pre><code><span class="hljs-type">expr</span> &amp; <span class="hljs-type">expr</span>
</code></pre><aside class="notes"><p>Union the machine.</p>
<p>Remove any final state status from any states that aren&#39;t final in both machines.</p>
<p>Paths that do not lead to a final state are pruned.</p></aside>
</section>
<section id="intersection-example" class="slide">
<h1>Intersection Example</h1><pre><code>%%{
  machine intersection;
  main := /[<span class="hljs-link_label">^\n</span>][<span class="hljs-link_reference">^\n</span>][<span class="hljs-link_label">^\n</span>][<span class="hljs-link_reference">^\n</span>]\n/<span class="hljs-bullet">* &amp; (/[a-z][a-z]*</span>/ | [ \n])**;
}%%
</code></pre><p><img src="images/intersection_example.png" alt=""></p>
</section>
<section id="difference" class="slide">
<h1>Difference</h1><p>Matches strings in machine one but not in machine two</p>
<pre><code><span class="hljs-type">expr</span> - <span class="hljs-type">expr</span>
</code></pre>
</section>
<section id="difference-example" class="slide">
<h2>Difference Example</h2><pre><code>%%{
  machine difference;
  # Subtract keywords from identifiers.
  main := /[<span class="hljs-link_label">a-z</span>][<span class="hljs-link_reference">a-z</span>]*/ - ( 'for' | 'int' );
}%%
</code></pre><p><img src="images/difference_example.png" alt=""></p>
</section>
<section id="strong-difference" class="slide">
<h1>Strong Difference</h1><p>Matches any string of the first machine that does not have any string of the second machine as a substring.</p>
<pre><code><span class="hljs-type">expr</span> -- <span class="hljs-type">expr</span>
</code></pre><p>Equivalent to:</p>
<pre><code><span class="hljs-type">expr</span> - ( <span class="hljs-type">any</span>* <span class="hljs-type">expr</span> <span class="hljs-type">any</span>* )
</code></pre>
</section>
<section id="strong-difference-example" class="slide">
<h2>Strong Difference Example</h2><p>Used to excluded CRLF from a sequence.</p>
<pre><code><span class="hljs-comment">%%{</span>
  <span class="hljs-atom">machine</span> <span class="hljs-atom">strong_difference</span>;
  <span class="hljs-atom">crlf</span> = <span class="hljs-string">'\r\n'</span>;
  <span class="hljs-atom">main</span> := [<span class="hljs-atom">a</span>-<span class="hljs-atom">z</span>]+ <span class="hljs-string">':'</span> ( <span class="hljs-atom">any</span>* -- <span class="hljs-atom">crlf</span> ) <span class="hljs-atom">crlf</span>;
}<span class="hljs-comment">%%</span>
</code></pre><p>The DEF transition is taken if no other transition can be taken.</p>
<p><img src="images/strong_difference_example.png" alt=""></p>
</section>
<section id="concatenation" class="slide" data-has-notes="true">
<h1>Concatenation</h1><p>Matches all the strings in machine one followed by all the strings in machine two.</p>
<pre><code><span class="hljs-type">expr</span> . <span class="hljs-type">expr</span>
</code></pre><p><img src="images/concatenation.png" alt=""></p><aside class="notes"><p>There is an oppotunity for non-determinism of matches from machine one prevent machine two from starting.</p>
<p>There are techniques for avoiding this.</p></aside>
</section>
<section id="concatenation-example" class="slide">
<h2>Concatenation Example</h2><pre><code><span class="hljs-comment">%%{</span>
  <span class="hljs-atom">machine</span> <span class="hljs-atom">concatenation</span>;
  #<span class="hljs-atom">concatenation</span>
  <span class="hljs-atom">main</span> := [<span class="hljs-atom">a</span>-<span class="hljs-atom">z</span>]+ . /<span class="hljs-atom">ba</span>[<span class="hljs-atom">rz</span>]/;
}<span class="hljs-comment">%%</span>
</code></pre><p><img src="images/concatenation_example.png" alt=""></p>
</section>
<section id="kleene-star" class="slide" data-has-notes="true">
<h1>Kleene Star</h1><p>Match zero or more repetitions of the machine it is applied to.</p>
<pre><code>expr<span class="hljs-keyword">*</span>
</code></pre><aside class="notes"><p>DANGER: The possibility for nondeterministic behaviour arises if the
final states have transitions on any of the same characters as the
start state.</p></aside>
</section>
<section id="kleene-star-example" class="slide">
<h1>Kleene Star Example</h1><pre><code>%%{
  machine kleene_star;
  # Match <span class="hljs-built_in">any</span> <span class="hljs-built_in">number</span> of lines <span class="hljs-keyword">with</span> only lowercase letters.
  main := <span class="hljs-regexp">/[a-z]*\n/</span>*;
}%%
</code></pre><p><img src="images/kleene_star_example.png" alt=""></p>
</section>
<section id="one-or-more-repetion" class="slide">
<h1>One or More Repetion</h1><p>Produces the concatenation of the machine with the kleene star of
itself. The result will match one or more repetitions of the machine.</p>
<pre><code><span class="hljs-type">expr</span>+
</code></pre><p>  Equivalent to:</p>
<pre><code><span class="hljs-type">expr</span> . <span class="hljs-type">expr</span>*
</code></pre>
</section>
<section id="optional" class="slide">
<h1>Optional</h1><pre><code><span class="hljs-type">expr</span>?
</code></pre><p>  Equivlaent to:</p>
<pre><code><span class="hljs-title">expr</span> | <span class="hljs-string">''</span>
</code></pre>
</section>
<section id="optional-example" class="slide">
<h2>Optional Example</h2><pre><code><span class="hljs-comment">%%{</span>
  <span class="hljs-atom">machine</span> <span class="hljs-atom">optional</span>;
  # <span class="hljs-name">Match</span> <span class="hljs-atom">integers</span> <span class="hljs-atom">or</span> <span class="hljs-atom">floats</span>.
  <span class="hljs-atom">main</span> := <span class="hljs-atom">digit</span>+ (<span class="hljs-string">'.'</span> <span class="hljs-atom">digit</span>+)?;
}<span class="hljs-comment">%%</span>
</code></pre><p><img src="images/optional_example.png" alt=""></p>
</section>
<section id="repetition" class="slide">
<h1>Repetition</h1><pre><code><span class="hljs-type">expr</span>{n} - exactly N copies <span class="hljs-keyword">of</span> <span class="hljs-type">expr</span>
<span class="hljs-type">expr</span>{n,} - <span class="hljs-type">Zero</span> to N copies <span class="hljs-keyword">of</span> <span class="hljs-type">expr</span>
<span class="hljs-type">expr</span>{,m} - N <span class="hljs-keyword">or</span> more copies <span class="hljs-keyword">of</span> <span class="hljs-type">expr</span>
<span class="hljs-type">expr</span>{n,m} - N to M copies <span class="hljs-keyword">of</span> <span class="hljs-type">expr</span>
</code></pre>
</section>
<section id="negation" class="slide">
<h1>Negation</h1><p>Matches any string not matched by the given machine.</p>
<pre><code><span class="hljs-change">!expr</span>
</code></pre><p>Equivalent to:</p>
<pre><code><span class="hljs-type">any</span>* - <span class="hljs-type">expr</span>
</code></pre>
</section>
<section id="negation-example" class="slide">
<h2>Negation Example</h2><pre><code>%%{
  machine negation;
  <span class="hljs-comment"># Accept anything but a string beginning with a digit.</span>
  main := !( digit any<span class="hljs-keyword">*</span> );
}%%
</code></pre><p><img src="images/kleene_star_example.png" alt=""></p>
</section>
<section id="character-level-negation" class="slide" data-has-notes="true">
<p><br></p>
<h2>Character- Level Negation</h2><pre><code><span class="hljs-comment">^expr</span>
</code></pre><p>Equivalent to:</p>
<pre><code><span class="hljs-type">any</span> - <span class="hljs-type">expr</span>
</code></pre><aside class="notes"><p>Must be applied to machines that match length one.</p></aside>
</section>
<section id="state-machine-minimization" class="slide">
<p><br></p>
<h2>State Machine Minimization</h2><ul>
<li>Reduces the number of states through optimization</li>
<li>Merges equivalent states</li>
<li>On by default (can be disabled with -n)</li>
</ul>
</section>
<section id="user-actions" class="slide">
<p><br></p>
<h1>User Actions</h1><p>  Composition is definitely cool and useful. But on top of that, Ragel
  gives you embedded actions. This is where you take all the
  composition and really make it sing, on key.</p>
</section>
<section id="embedding-actions" class="slide">
<p><br></p>
<h1>Embedding Actions</h1><pre><code>  <span class="hljs-title">action</span> &lt;action_name&gt; {
    <span class="hljs-comment"># host code here</span>
    <span class="hljs-title">count</span> += <span class="hljs-number">1</span>
  }
</code></pre><p>Actions can be referenced by name or embedded inline.</p>
</section>
<section id="transitions" class="slide">
<p><br></p>
<h1>Transitions</h1><p>Transitions come in four classes, and actions can be attached to any of them.</p>
</section>
<section id="entering-transition" class="slide">
<p><br></p>
<h1>Entering Transition</h1><pre><code>  &gt; operator

  <span class="hljs-keyword">expr</span> &gt; action_name
  <span class="hljs-keyword">expr</span> &gt;{ <span class="hljs-keyword">puts</span> <span class="hljs-string">"entering"</span> }
</code></pre><p>Embeds an action into all transitions leaving the &quot;start state&quot;</p>
</section>
<section id="finishing-transition" class="slide">
<p><br></p>
<h1>Finishing Transition</h1><pre><code>  @ operator

  <span class="hljs-keyword">expr</span> @ action_name
  <span class="hljs-keyword">expr</span> @{ <span class="hljs-keyword">puts</span> <span class="hljs-string">"finishing"</span> }
</code></pre><p>Embeds an action into all transitions going into a &quot;final state&quot;</p>
</section>
<section id="all-transition" class="slide">
<p><br></p>
<h1>All Transition</h1><pre><code>  <span class="hljs-variable">$ </span>operator

  expr <span class="hljs-variable">$ </span>action_name
  expr <span class="hljs-variable">${</span> puts <span class="hljs-string">"transitioned"</span> }
</code></pre><p>Embeds an action into all transitions, regardless of type (useful for debugging).</p>
</section>
<section id="leaving-transition" class="slide">
<p><br></p>
<h1>Leaving Transition</h1><pre><code>  % operator
  <span class="hljs-keyword">expr</span> % action_name
  <span class="hljs-keyword">expr</span> %{ <span class="hljs-keyword">puts</span> <span class="hljs-string">"leaving"</span> }
</code></pre><p>Embeds an action into all transitions leaving the machine from a &quot;final state&quot;</p>
</section>
<section id="embedding-operators-can-get-fancy" class="slide">
<p><br></p>
<h2>Embedding Operators Can Get Fancy</h2><p>See the manual for more information on these.</p>
<ul>
<li>To-State Actions</li>
<li>From-State Actions</li>
<li>EOF Actions</li>
<li>Global Error Actions (for error recovery)</li>
<li>Local Error Actions  (for error recovery)</li>
</ul>
</section>
<section id="nondeterminism" class="slide">
<p><br></p>
<h1>Nondeterminism</h1><p>One of the problems you will run into is when the trailing match of
one machine is the same as the leading match of the next machine. In
these cases, the state will be stuck in the first machine and never
transition to the next machine.</p>
</section>
<section id="nonedeterminism-example" class="slide">
<h2>Nonedeterminism Example</h2><p>The \n in ws will preven the final \n from matching.</p>
<pre><code>ws = [\n\t ];
line = word <span class="hljs-variable">$first</span> ( ws word <span class="hljs-variable">$tail</span> )* ’\n’;
lines = line*;
</code></pre><p>The solution here is simple: exclude the newline character from the ws expression.</p>
<pre><code>ws = [\t ];
line = word <span class="hljs-variable">$first</span> ( ws word <span class="hljs-variable">$tail</span> )* ’\n’;
lines = line*;
</code></pre>
</section>
<section id="ambiguity-problems" class="slide">
<p><br></p>
<h1>Ambiguity Problems</h1><p>Here&#39;s an incorrect way to parse C language comments:</p>
<pre><code><span class="hljs-title">comment</span> = ’/*’ ( any <span class="hljs-variable">@comm</span> )* ’*/’;
<span class="hljs-title">main</span> := comment ’ ’;
</code></pre><p>The <code>any</code> will prevent the trailing */ from ever matching.</p>
</section>
<section id="this-works-but-its-ugly" class="slide">
<p><br><br></p>
<h2>This Works But It&#39;s Ugly</h2><pre><code>comment = ’/<span class="hljs-emphasis">*’ ( ( any @comm )*</span> - ( any<span class="hljs-bullet">* ’*</span>/’ any<span class="hljs-bullet">* ) ) ’*</span>/’;
</code></pre><p>We have to carefully exclude things to get it to match.</p>
</section>
<section id="this-is-getting-complicated" class="slide">
<p><br><br></p>
<h2>This Is Getting Complicated!</h2><p>But there&#39;s a solution.</p>
<p>Ragel lets you embed priorities into transitions to deal with ambiguity.</p>
</section>
<section id="setting-priorities-manually" class="slide">
<p><br></p>
<h2>Setting Priorities Manually</h2><pre><code>  expr &gt; <span class="hljs-keyword">int</span> – Sets starting transitions <span class="hljs-keyword">to</span> have priority <span class="hljs-keyword">int</span>.

  expr @ <span class="hljs-keyword">int</span> – Sets transitions that <span class="hljs-keyword">go</span> into <span class="hljs-keyword">a</span> final state <span class="hljs-keyword">to</span> have priority <span class="hljs-keyword">int</span>.

  expr $ <span class="hljs-keyword">int</span> – Sets <span class="hljs-keyword">all</span> transitions <span class="hljs-keyword">to</span> have priority <span class="hljs-keyword">int</span>.

  expr % <span class="hljs-keyword">int</span> – Sets leaving transitions <span class="hljs-keyword">to</span> have priority <span class="hljs-keyword">int</span>.
</code></pre>
</section>
<section id="namespacing-priorities" class="slide">
<p><br></p>
<h2>Namespacing Priorities</h2><p>When machines are combined, you can get odd interactions if you
don&#39;t namespace the priorities.</p>
<pre><code>  expr &gt; (<span class="hljs-keyword">name</span>, <span class="hljs-built_in">int</span>) – Starting transitions.
  expr @ (<span class="hljs-keyword">name</span>, <span class="hljs-built_in">int</span>) – Finishing transitions (into a <span class="hljs-keyword">final</span> state).
  expr $ (<span class="hljs-keyword">name</span>, <span class="hljs-built_in">int</span>) – <span class="hljs-built_in">All</span> transitions.
  expr % (<span class="hljs-keyword">name</span>, <span class="hljs-built_in">int</span>) – Leaving transitions.
</code></pre>
</section>
<section id="guarded-operations" class="slide">
<p><br></p>
<h1>Guarded Operations</h1><p>Thinking in priorities is hard.</p>
<p>Fortunately Ragel provides some better mechanisms for us to use.</p>
<p>These are called &quot;guarded concatenations&quot;</p>
</section>
<section id="finishguarded-concatenation" class="slide" data-has-notes="true">
<p><br></p>
<h2>Finish-Guarded Concatenation</h2><p>A higher priority is then embedded into the transitions of the second machine that enter into a final state.</p>
<pre><code>comment = ’/*’ ( any <span class="hljs-variable">@comm</span> )* <span class="hljs-symbol">:&gt;&gt;</span> ’*<span class="hljs-regexp">/’;</span>
</code></pre><p>This is much simpler to visualize and reason about.</p><aside class="notes"><p>As soon as we hit a &#39;*/&#39; while in the comment, we will match and exit the comment.</p></aside>
</section>
<section id="entryguarded-concatenation" class="slide" data-has-notes="true">
<p><br></p>
<h2>Entry-Guarded Concatenation</h2><p>A higher priority is given to the second machine.</p>
<pre><code><span class="hljs-type">expr</span> :&gt; <span class="hljs-type">expr</span>
</code></pre><pre><code><span class="hljs-comment"># Leave the catch-all machine on the first character of FIN.</span>
main <span class="hljs-symbol">:</span>= any* <span class="hljs-symbol">:&gt;</span> <span class="hljs-string">'FIN'</span>;
</code></pre><p>Equivalent to:</p>
<pre><code>expr $(unique_name,<span class="hljs-number">0</span>) . expr &gt;(unique_name,<span class="hljs-number">1</span>)
</code></pre><aside class="notes"><p>As soon as we hit an &#39;F&#39;, we will leave the first machine an start matching the second.</p></aside>
</section>
<section id="leftguarded-concatenation" class="slide" data-has-notes="true">
<p><br></p>
<h2>Left-Guarded Concatenation</h2><p>The left hand machine has a higher priority.</p>
<pre><code><span class="hljs-type">expr</span> &lt;: <span class="hljs-type">expr</span>
</code></pre><p>For stripping leading space:</p>
<pre><code>main := ( ’ ’* &gt;<span class="hljs-keyword">start</span> <span class="hljs-decorator">%fin</span> ) &lt;: ( ’ ’ <span class="hljs-variable">$ws</span> | [a-z] <span class="hljs-variable">$alpha</span> )*;
</code></pre><aside class="notes"><p>This allows the left machine to greedily eat any spaces. The second machine won&#39;t match a space until it is already being matched, having had a letter appear already.</p></aside>
</section>
<section id="longestmatch-kleene-star" class="slide">
<p><br></p>
<h2>Longest-Match Kleene Star</h2><p>This has a higher priority for staying in the machine rather than wrapping around again.</p>
<pre><code>expr<span class="hljs-keyword">*</span><span class="hljs-keyword">*</span>
</code></pre><pre><code><span class="hljs-comment"># Repeat tokens, but make sure to get the longest match.</span>
Main := (
  lower ( lower |<span class="hljs-string"> digit )* %A </span>|<span class="hljs-string"> digit+ %B </span>|
  ''
)<span class="hljs-keyword">*</span><span class="hljs-keyword">*</span>;
</code></pre>
</section>
<section id="scanners" class="slide" data-has-notes="true">
<h1>Scanners</h1><p>Scanners are a common thing to build with Ragel, so it has special support for them.</p>
<pre><code>    &lt;machine_name&gt; := |*
      pattern1 =&gt; action1<span class="hljs-comment">;</span>
      pattern2 =&gt; action2<span class="hljs-comment">;</span>
      ...
    *|<span class="hljs-comment">;</span>
</code></pre><aside class="notes"><p>On the surface, Ragel scanners are similar to those defined by Lex.</p>
<p>Though there is a key distinguishing feature: patterns may be arbitrary Ragel expressions and can therefore contain embedded
code.</p>
<p>With a Ragel-based scanner the user need not wait until the end of a pattern before user code can be executed.</p>
<p>Scanners can be used to process sub-languages, as well as for tokenizing programming languages.</p></aside>
</section>
<section id="scanner-example" class="slide">
<p><br></p>
<h2>Scanner Example</h2><p>Tokenizing the contents of a header field.</p>
<pre><code>%%{
  word = [a-z]+<span class="hljs-comment">;</span>
  head_name = 'Header'<span class="hljs-comment">;</span>
  header := |*
    word<span class="hljs-comment">;</span>
    ' '<span class="hljs-comment">;</span>
    '\n' =&gt; { fret<span class="hljs-comment">; };</span>
  *|<span class="hljs-comment">;</span>
  main := ( head_name ':' @{ fcall header<span class="hljs-comment">; } )*;</span>
}%%
</code></pre>
</section>
<section id="protocol-parsing" class="slide">
<h1>Protocol Parsing</h1><p>Ragel is well suited for protocol parsing.</p>
<p>Mapping an RFC onto a Ragel specification is pretty straight-forward.</p>
<p>Puma has a good example of this (heritage is the original mongrel parser by Zed Shaw)</p>
<p><small>
<a href="https://github.com/puma/puma/blob/master/ext/puma_http11/http11_parser_common.rl">https://github.com/puma/puma/blob/master/ext/puma_http11/http11_parser_common.rl</a>
</small></p>
</section>
<section id="state-charts" class="slide">
<p><br></p>
<h1>State Charts</h1><p>Ragel allows you to specify states and transitions directly if you desire extreme customization.</p>
<p>This is like programming in the &quot;assembly&quot; of Ragel.</p>
<p>There are a few new operators for this.</p>
</section>
<section id="state-chart-example" class="slide">
<h2>State Chart Example</h2><p>Parsing XML CDATA.</p>
<pre><code>action bchar { buff( fpc ); }
action bbrack1 { buff( <span class="hljs-string">"]"</span> ); }
action bbrack2 { buff( <span class="hljs-string">"]]"</span> ); }
CDATA_body =
<span class="hljs-attribute">start</span>: (
<span class="hljs-string">']'</span><span class="hljs-function"> -&gt;</span> one |
     (any-<span class="hljs-string">']'</span>) <span class="hljs-property">@bchar</span><span class="hljs-function"> -&gt;</span>start
),
<span class="hljs-attribute">one</span>: (
     <span class="hljs-string">']'</span><span class="hljs-function"> -&gt;</span> two |
     [^<span class="hljs-string">\]]</span> <span class="hljs-property">@bbrack1</span> <span class="hljs-property">@bchar</span><span class="hljs-function"> -&gt;</span>start
),
<span class="hljs-attribute">two</span>: (
     <span class="hljs-string">'&gt;'</span><span class="hljs-function"> -&gt;</span> final |
     <span class="hljs-string">']'</span> <span class="hljs-property">@bbrack1</span><span class="hljs-function"> -&gt;</span> two |
     [^&gt;<span class="hljs-string">\]]</span> <span class="hljs-property">@bbrack2</span> <span class="hljs-property">@bchar</span><span class="hljs-function"> -&gt;</span>start
);
</code></pre>
</section>
<section id="parser-modularization" class="slide" data-has-notes="true">
<h2>Parser Modularization</h2><pre><code>    <span class="hljs-atom">action</span> <span class="hljs-atom">return</span> { <span class="hljs-atom">fret</span>; }
    <span class="hljs-atom">action</span> <span class="hljs-atom">call_date</span> { <span class="hljs-atom">fcall</span> <span class="hljs-atom">date</span>; }
    <span class="hljs-atom">action</span> <span class="hljs-atom">call_name</span> { <span class="hljs-atom">fcall</span> <span class="hljs-atom">name</span>; }

    # <span class="hljs-name">A</span> <span class="hljs-atom">parser</span> <span class="hljs-atom">for</span> <span class="hljs-atom">date</span> <span class="hljs-atom">strings</span>.
    <span class="hljs-atom">date</span> := [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>] <span class="hljs-string">'/'</span>
            [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>] <span class="hljs-string">'/'</span>
            [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>] <span class="hljs-string">'\n'</span> @<span class="hljs-atom">return</span>;

    # <span class="hljs-name">A</span> <span class="hljs-atom">parser</span> <span class="hljs-atom">for</span> <span class="hljs-atom">name</span> <span class="hljs-atom">strings</span>.
    <span class="hljs-atom">name</span> := ( [<span class="hljs-atom">a</span>-<span class="hljs-atom">zA</span>-<span class="hljs-name">Z</span>]+ | <span class="hljs-string">' '</span> )** <span class="hljs-string">'\n'</span> @<span class="hljs-atom">return</span>;

    # <span class="hljs-name">The</span> <span class="hljs-atom">main</span> <span class="hljs-atom">parser</span>.
    <span class="hljs-atom">headers</span> =
        ( <span class="hljs-string">'from'</span> | <span class="hljs-string">'to'</span> ) <span class="hljs-string">':'</span> @<span class="hljs-atom">call_name</span> |
        ( <span class="hljs-string">'departed'</span> | <span class="hljs-string">'arrived'</span> ) <span class="hljs-string">':'</span> @<span class="hljs-atom">call_date</span>;

    <span class="hljs-atom">main</span> := <span class="hljs-atom">headers</span>*;
</code></pre><aside class="notes"><p>You can use fcall and fret to jump around in the parser, like function calls.</p></aside>
</section>
<section id="parsing-recursive-structures" class="slide">
<p><br></p>
<h2>Parsing Recursive Structures</h2><p>The general trick is to store some context about where you are in your
recursive structure, say in a stack called @nestings, and push/pop to
it as appropriate. When it comes time to call <code>fret</code>, you can examine your
@nestings and steer the parser as deemed appropriate.</p>
</section>
<section id="implementing-lookahead" class="slide">
<p><br></p>
<h2>Implementing Lookahead</h2><p>This is possible. The trick here is to match deeper than you need, then use <code>fhold</code> to walk the parser back a few characters.</p>
</section>
<section id="ragel-internals" class="slide">
<h2>Ragel Internals</h2><p>Ragel uses several variables for state. You can twiddle them in actions.</p>
<pre><code>* <span class="hljs-type">data</span> - the buffer <span class="hljs-keyword">where</span> you should store the <span class="hljs-type">data</span>
* p    - start <span class="hljs-built_in">index</span> <span class="hljs-type">in</span> <span class="hljs-type">data</span> <span class="hljs-keyword">where</span> Ragel is matching
* pe   - <span class="hljs-keyword">end</span> <span class="hljs-built_in">index</span> of <span class="hljs-type">data</span> (Ragel should ignore anything past this)
* ts   - <span class="hljs-type">in</span> a scanner, token start
* te   - <span class="hljs-type">in</span> a scanner, token <span class="hljs-keyword">end</span>
* act  - <span class="hljs-type">in</span> a scanner, last matched <span class="hljs-keyword">action</span>
</code></pre><p>Those are the major ones. See the manual for more details.</p>
</section>
<section id="ragel-operation-roughly" class="slide">
<p><br></p>
<h2>Ragel Operation (roughly)</h2><ol>
<li>Starts in state 0</li>
<li>Feed it data, updating <code>p</code> and <code>pe</code> as appropriate</li>
<li>Run the <code>%%exec</code> loop</li>
<li>Characters move it through a state</li>
<li>It consumes <code>p -&gt; pe</code> from <code>data</code></li>
<li>If <code>cs</code> is <code>&gt;= first_final_state</code> (final states are last) then you have “admitted” the string</li>
</ol>
</section>
<section id="ragel-operation-scanners" class="slide">
<p><br></p>
<h2>Ragel Operation (scanners)</h2><p>Scanners are a bit more involved, but not that much more.</p>
<ol>
<li>Use a stack to track states</li>
<li>Use ts -&gt; te to track where they are in a match</li>
<li>Use the stack to backtrack when necessary</li>
<li>Keep matching repeatedly until we are done</li>
<li>Longest match wins</li>
<li>It&#39;s useful to create helper methods (<code>emit</code>, <code>current_buffer</code>, <code>current_match(start, end)</code>)</li>
</ol>
</section>
<section id="ragel-string-extraction" class="slide">
<p><br></p>
<h2>Ragel String Extraction</h2><p>To pull out the data you care about, while you are parsing, you will do something like this:</p>
<pre><code>* &gt;mark { puts <span class="hljs-string">"mark the beginning a pattern"</span> ; <span class="hljs-variable">@mark</span> = <span class="hljs-variable">@data</span>[p] }
* <span class="hljs-variable">%emit</span> l{ puts <span class="hljs-string">"save the currently matched pattern"</span> ; <span class="hljs-variable">@things</span> &lt;&lt; data[<span class="hljs-variable">@mark</span>..pe] }
</code></pre>
</section>
<section id="host-languages" class="slide">
<h2>Host Languages</h2><p>Several host languages are available.</p>
<pre><code>    host language:
       -<span class="ruby"><span class="hljs-constant">C</span>    <span class="hljs-constant">The</span> host language is <span class="hljs-constant">C</span>, <span class="hljs-constant">C</span>++, <span class="hljs-constant">Obj</span>-<span class="hljs-constant">C</span> <span class="hljs-keyword">or</span> <span class="hljs-constant">Obj</span>-<span class="hljs-constant">C</span>++ (default)
</span>       -<span class="ruby"><span class="hljs-constant">D</span>    <span class="hljs-constant">The</span> host language is <span class="hljs-constant">D</span>
</span>       -<span class="ruby"><span class="hljs-constant">Z</span>    <span class="hljs-constant">The</span> host language is <span class="hljs-constant">Go</span>
</span>       -<span class="ruby"><span class="hljs-constant">J</span>    <span class="hljs-constant">The</span> host language is <span class="hljs-constant">Java</span>
</span>       -<span class="ruby"><span class="hljs-constant">R</span>    <span class="hljs-constant">The</span> host language is <span class="hljs-constant">Ruby</span>
</span>       -<span class="ruby"><span class="hljs-constant">A</span>    <span class="hljs-constant">The</span> host language is <span class="hljs-constant">C</span><span class="hljs-comment">#</span>
</span>       -<span class="ruby"><span class="hljs-constant">O</span>    <span class="hljs-constant">The</span> host language is <span class="hljs-constant">OCaml</span></span>
</code></pre>
</section>
<section id="code-styles" class="slide">
<h2>Code Styles</h2><p>Ragel uses your .rl code to compute the set of states and transitions. From that, it can generate code in a number of different styles.</p>
<pre><code>    code style:<span class="hljs-function"> (</span>C/D/Java/Ruby/C<span class="hljs-comment">#/OCaml)</span>
       -T0                  Table driven FSM<span class="hljs-function"> (</span>default<span class="hljs-function">)</span>

    code style:<span class="hljs-function"> (</span>C/D/Ruby/C<span class="hljs-comment">#/OCaml)</span>
       -T1                  Faster table driven FSM
       -F0                  Flat table driven FSM
       -F1                  Faster flat table-driven FSM

    code style:<span class="hljs-function"> (</span>C/D/C<span class="hljs-comment">#/OCaml)</span>
       -G0                  Goto-driven FSM
       -G1                  Faster<span class="hljs-instruction"> goto-driven </span>FSM

    code style:<span class="hljs-function"> (</span>C/D<span class="hljs-function">)</span>
       -G2                  Really fast<span class="hljs-instruction"> goto-driven </span>FSM
       -P&lt;N&gt;                N-Way Split really fast<span class="hljs-instruction"> goto-driven </span>FSM
</code></pre>
</section>
<section id="code-styles-performance" class="slide">
<p><br><br></p>
<h2>Code Styles Performance</h2><p>Each of these has different visual organization and performance
characteristics. In languages like C, this can boil down to
heavily-optimized GOTO statements in a single while loop. It&#39;s fast
and cpu-cache friendly.</p>
</section>
<section id="multilanguage" class="slide">
<p><br></p>
<h2>Multi-Language</h2><p>It&#39;s possible to have a single Ragel definition that uses import semantics to allow implementing the actions in different languages using the same parent Ragel file. See the http11 parser in puma for details (C and Java)</p>
<p><small>
<a href="https://github.com/puma/puma/tree/master/ext/puma_http11">https://github.com/puma/puma/tree/master/ext/puma_http11</a>
</small></p>
</section>
<section id="ragel-in-c" class="slide">
<p><br><br></p>
<h2>Ragel in C</h2><p>It&#39;s also possible to prototype in Ruby, then convert it to a C module for super speed. Ragel supports several output formats so you can do this port rather easily.</p>
<p>Again, see mongrel or puma for ideas.</p>
</section>
<section id="ragel-directives-init" class="slide">
<p><br><br></p>
<h2>Ragel Directives - init</h2><p>Initializes the data buffer and sets the current state:</p>
<pre><code><span class="hljs-tag">  %<span class="hljs-title">write</span></span> init;
</code></pre>
</section>
<section id="ragel-directives-data" class="slide">
<p><br><br></p>
<h2>Ragel Directives - data</h2><p>Writes out definitions of the state and transition data:</p>
<pre><code>  %%<span class="hljs-built_in">write</span> <span class="hljs-type">data</span>;
</code></pre>
</section>
<section id="ragel-directives-exec" class="slide">
<p><br><br></p>
<h2>Ragel Directives - exec</h2><p>Writes out the code that processes the data buffer using the state and transition data</p>
<pre><code><span class="xml"></span><span class="perl">  <span class="hljs-variable">%%</span><span class="hljs-keyword">write</span> <span class="hljs-keyword">exec</span>;</span><span class="xml"></span>
</code></pre>
</section>
<section id="write-data" class="slide">
<h2>%%write data;</h2><pre><code>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-inheritance">&lt;</span><span class="hljs-inheritance">&lt; <span class="hljs-parent">self</span></span></span>
    <span class="hljs-keyword">attr_accessor</span> <span class="hljs-symbol">:_hello_key_offsets</span>
    private <span class="hljs-symbol">:_hello_key_offsets</span>, <span class="hljs-symbol">:_hello_key_offsets=</span>
  <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">self</span>._hello_key_offsets = [
    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>
  ]

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-inheritance">&lt;</span><span class="hljs-inheritance">&lt; <span class="hljs-parent">self</span></span></span>
    <span class="hljs-keyword">attr_accessor</span> <span class="hljs-symbol">:_hello_trans_keys</span>
    private <span class="hljs-symbol">:_hello_trans_keys</span>, <span class="hljs-symbol">:_hello_trans_keys=</span>
  <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">self</span>._hello_trans_keys = [
    <span class="hljs-number">101</span>, <span class="hljs-number">108</span>, <span class="hljs-number">108</span>, <span class="hljs-number">111</span>, <span class="hljs-number">104</span>, <span class="hljs-number">0</span>
  ]
  <span class="hljs-comment"># LOTS MORE LIKE THIS</span>
  <span class="hljs-comment"># ...</span>
  <span class="hljs-comment"># ...</span>
</code></pre>
</section>
<section id="write-init" class="slide">
<p><br></p>
<h2>%%write init;</h2><pre><code>  <span class="hljs-operator"><span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">p</span> ||= <span class="hljs-number">0</span>
    pe ||= <span class="hljs-keyword">data</span>.<span class="hljs-keyword">length</span>
    cs = simple_start
    top = <span class="hljs-number">0</span>
  <span class="hljs-keyword">end</span></span>
</code></pre>
</section>
<section id="write-exec" class="slide">
<h2>%%write exec;</h2><pre><code>   begin
    _klen, _trans, _keys = nil
    _goto_level = <span class="hljs-number">0</span>
    _resume = <span class="hljs-number">10</span>
    _eof_trans = <span class="hljs-number">15</span>
    _again = <span class="hljs-number">20</span>
    _test_eof = <span class="hljs-number">30</span>
    _out = <span class="hljs-number">40</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>
    _trigger_goto = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">if</span> _goto_level &lt;= <span class="hljs-number">0</span>
    <span class="hljs-preprocessor"># LOTS MORE LIKE THIS</span>
    <span class="hljs-preprocessor"># ...</span>
    <span class="hljs-preprocessor"># ...    </span>
  end
</code></pre>
</section>
<section id="installation" class="slide">
<p><br></p>
<h1>Installation</h1><pre><code><span class="hljs-keyword">brew </span>install ragel
</code></pre>
</section>
<section id="generating-the-ruby" class="slide">
<p><br></p>
<h2>Generating the Ruby</h2><p>simple.rl -&gt; simple.rb</p>
<pre><code><span class="hljs-tag">ragel</span> <span class="hljs-tag">-R</span> <span class="hljs-tag">simple</span><span class="hljs-class">.rl</span> <span class="hljs-tag">-o</span> <span class="hljs-tag">simple</span><span class="hljs-class">.rb</span>
</code></pre>
</section>
<section id="visualization" class="slide">
<p><br></p>
<h2>Visualization</h2><p>You can get a dotviz graph.</p>
<pre><code>  ragel -V simple<span class="hljs-class">.rl</span> &gt; simple<span class="hljs-class">.dot</span>
  dot -Tsvg simple<span class="hljs-class">.dot</span> -o simple.svg
</code></pre>
</section>
<section id="calling-from-ruby" class="slide">
<p><br></p>
<h2>Calling From Ruby</h2><p>To run on a single buffer of String data:</p>
<pre><code>   def ragel_parse(<span class="hljs-type">data</span>)
     <span class="hljs-type">data</span> = <span class="hljs-type">data</span>.<span class="hljs-built_in">unpack</span>(<span class="hljs-string">"c*"</span>)
     eof = <span class="hljs-type">data</span>.length
     tokens = []

     %% <span class="hljs-built_in">write</span> init;
     %% <span class="hljs-built_in">write</span> exec;

     puts tokens.inspect
   <span class="hljs-keyword">end</span>
</code></pre>
</section>
<section id="ragel-playground" class="slide" data-has-notes="true">
<p><br></p>
<h2>Ragel Playground</h2><p>I created a tool in Volt to do some basic visualization.</p>
<p><a href="https://github.com/ijcd/ragel_playground">https://github.com/ijcd/ragel_playground</a></p>
<p>It&#39;s definitely a work in progress, but feel free to try it out.</p><aside class="notes"><p>Volt is very cool, by the way. You can do reactive programming without ever stepping out of Ruby. Give it a try if you haven&#39;t already.</p></aside>
</section>
<section id="demos" class="slide" data-has-notes="true">
<p><br></p>
<h1>Demos</h1><ol>
<li>hello parser</li>
<li>args parser</li>
<li>args state chart</li>
</ol><aside class="notes"><p>Walk through a generated ‘hello’ file line by line and explain what is
going on (data jump tables, start/end states, execution code)</p>
<p>How does it work?</p>
<p>Note:</p>
<p>Walk through a generated ‘hello’ file line by line and explain what is
going on (data jump tables, start/end states, execution code)</p>
<p>How does it work?</p></aside>
</section>
<section id="talk-to-me-baby" class="slide">
<h1>Talk to me, baby!</h1><p>@ijcd</p>
<p>github.com/ijcd</p>
<p><a href="https://github.com/ijcd/ragel_playground">https://github.com/ijcd/ragel_playground</a></p>
<p><a href="https://github.com/ijcd/rubyconf-2015-ragel">https://github.com/ijcd/rubyconf-2015-ragel</a></p>
<p><a href="http://www.colm.net/open-source/ragel/">http://www.colm.net/open-source/ragel/</a></p>
</section>
<section>

</section></div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,

      transition: Reveal.getQueryHash().transition || 'slide', // none/fade/slide/convex/concave/zoom

      // Optional reveal.js plugins
      dependencies: [
        //{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        //{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        //{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: 'plugin/zoom-js/zoom.js', async: true },
        { src: 'plugin/notes/notes.js', async: true }
      ]
    });
    </script>

    <script src="js/dynamic-theme.js"></script><script src="js/custom.js"></script>

  </body>
</html>
